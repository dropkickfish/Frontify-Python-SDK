schema {
  query: RootQuery
  mutation: RootMutation
}

type Audio implements Node & Asset {
  "`Asset` id."
  id: ID!

  "The `User` who created the `Asset`."
  creator: User!

  "`DateTime` of the `Asset` creation."
  createdAt: DateTime!

  "The `User` who last modified the `Asset`."
  modifier: User

  "`DateTime` of the `Asset` last modification."
  modifiedAt: DateTime

  "Title of the `Asset`."
  title: String!

  "Description of the `Asset`."
  description: String

  "**BETA** Alternative text for the `Asset`. Used by screen readers when the asset is not decorative."
  alternativeText: String

  "**BETA** Indicates whether the `Asset` is decorative and not meant to be read by screen readers. If true, alternative text is ignored."
  isDecorative: Boolean!

  "`Attachment` items linked to `Asset`."
  attachments: [AssetAttachment]

  "External Id of the `Asset`."
  externalId: ID

  "List of `Tag` items linked to `Asset`"
  tags: [Tag]

  "**DEPRECATED** `MetadataValue` items linked to `Asset`. This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataValues: [MetadataValue] @deprecated(reason: "This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `ExternalProduct` items linked to `Asset`. This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00"
  externalProducts: [ExternalProduct] @deprecated(reason: "This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00")

  "`Asset` copyright details."
  copyright: Copyright

  "**BETA** `Asset` will be available only during the defined `DateTime` range.When `null` it represents an unspecified start and\/or open-ended date."
  availability: DateTimeRange!

  "`Asset` available until date."
  expiresAt: DateTime

  "`License` items linked to `Asset`."
  licenses: [License]

  "Represents the Author of the `Asset`. Example: Photographer Name."
  author: String

  "Represents the conversion status of the `Asset`. Example: FINISHED."
  status: AssetStatusType!

  "Paginated list of `Asset` items related to `Asset`."
  relatedAssets(
    "How many `Asset` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "Paginated list of `AssetComment` items for `Asset`."
  comments(
    "How many `AssetComment` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "`AssetComment` query for results filtering."
    query: AssetCommentQueryInput
  ): AssetCommentItems

  "Current `User` `Asset` permissions."
  currentUserPermissions: AssetUserPermissions!

  "List of `CustomMetadataProperty` items and values associated to `Asset`."
  customMetadata: [CustomMetadata!]!

  "**BETA** The `WorkflowTask` this `Asset` is linked to."
  workflowTask: WorkflowTask

  "**BETA** `AssetVariant` items of the asset."
  variants(
    "How many `AssetVariant` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetVariantItems

  "`Location` of the `Asset`."
  location: AssetLocation!

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColor

  "Original filename of the `Asset` `File`."
  filename: String

  "Size of the `Asset` `File` in bytes."
  size: BigInt

  "Extension of the `Asset` `File`."
  extension: String!

  "Signed `Url` to download the original `Audio` type file."
  downloadUrl(
    "Download `Url` validity in days. Defaults to `1` when both `validityInDays` and `permanent` arguments are not specified."
    validityInDays: Int

    "Download `Url` validity state. When `true`, `Url` will be indefinitely valid, unless explicitly stated otherwise in the `validityInDays` argument."
    permanent: Boolean
  ): Url

  "Preview `Url` of converted `Audio` file in mp3 format."
  previewUrl(
    "`Audio` preview width value in pixels."
    width: Int

    "`Audio` preview height value in pixels."
    height: Int
  ): Url!

  "Provides a `Url` for the custom user defined thumbnail or a system generated one when possible."
  thumbnailUrl: Url

  "**BETA** The dynamic preview `Url` of the `Asset`. Dynamically points to the latest revision's preview."
  dynamicPreviewUrl: Url
}

"`NodeInterface` is the base for all types."
interface Node {
  "`Node` Id."
  id: ID!
}

"`AssetInterface` for `Asset` returnable types."
interface Asset {
  "`Asset` id."
  id: ID!

  "The `creator` is the `User` who created the asset on Frontify."
  creator: User!

  "DateTime of the `Asset` creation."
  createdAt: DateTime!

  "The `modifier` is the `User` who last modified the asset on Frontify."
  modifier: User

  "DateTime of the `Asset`'s last modification."
  modifiedAt: DateTime

  "Title of the `Asset`."
  title: String!

  "Description of the `Asset`."
  description: String

  "List of `Asset`'s `Attachments`."
  attachments: [AssetAttachment]

  "External Id of the `Asset`."
  externalId: ID

  "List of `Asset`'s tags."
  tags: [Tag]

  "`Asset` copyright details."
  copyright: Copyright

  "**BETA** `Asset` will be available only during the defined `DateTime` range.When `null` it represents an unspecified start and\/or open-ended date."
  availability: DateTimeRange!

  "`Asset` available until date."
  expiresAt: DateTime

  "List of `Asset`'s licenses."
  licenses: [License]

  "**DEPRECATED** Metadata values details. This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataValues: [MetadataValue] @deprecated(reason: "This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "Represents the conversion status of the `Asset`. Example: FINISHED."
  status: AssetStatusType!

  "Paginated list of `Asset` items related to `Asset`."
  relatedAssets(
    "How many `Asset` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "Paginated list of `AssetComment` items for `Asset`."
  comments(
    "How many `AssetComment` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Additional querying options."
    query: AssetCommentQueryInput
  ): AssetCommentItems

  "`Asset` permissions of the current `User`."
  currentUserPermissions: AssetUserPermissions!

  "List of `CustomMetadataProperty` items and values associated to `Asset`."
  customMetadata: [CustomMetadata!]!

  "**BETA** The `WorkflowTask` this `Asset` is linked to."
  workflowTask: WorkflowTask

  "**BETA** `AssetVariant` items of the asset."
  variants(
    "How many `AssetVariant` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetVariantItems

  "`Location` of the `Asset`."
  location: AssetLocation!

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColor
}

"`UserInterface` for `User` returnable types."
interface User {
  "`User` Id."
  id: ID!

  "**DEPRECATED** `User` email. This field will be removed. Use `AccountUser.email` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  email: Email! @deprecated(reason: "This field will be removed. Use `AccountUser.email` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "`User` name."
  name: String

  "**DEPRECATED** `User` avatar. This field will be removed. Use `AccountUser.avatar` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  avatar: Url @deprecated(reason: "This field will be removed. Use `AccountUser.avatar` instead. | Date: 2025-07-01T00:00:00.000+00:00")
}

"The `Email` scalar type represents email addresses."
scalar Email

"The `Url` scalar type represents absolute urls."
scalar Url

"The `DateTime` scalar type represents datetime data in RFC3339_EXTENDED format (ie. 2001-12-31T22:10:30.000+00:00)"
scalar DateTime

"`AttachmentInterface` for `Attachment` returnable types."
interface Attachment {
  "`Attachment` Id."
  id: ID!

  "The `User` who created the `Attachment` on Frontify."
  creator: User!

  "`DateTime` of the `Attachment` creation."
  createdAt: DateTime!

  "The `User` who last modified the `Attachment` on Frontify."
  modifier: User

  "`DateTime` of the `Attachment`'s last modification."
  modifiedAt: DateTime

  "The `Attachment`'s filename."
  filename: String

  "The `Attachment`'s name or title."
  name: String

  "The `Attachment`'s original file extension."
  extension: String

  "The `Attachment`'s Media (MIME) type."
  type: String

  "The `Attachment`'s size in bytes."
  size: BigInt

  "The `Attachment`'s External Id."
  externalId: ID
}

"The `BigInt` scalar type represents big integers (2^63 signed)."
scalar BigInt

type Tag {
  "`Tag` value."
  value: String!

  "`Tag` source indicating how the tag was linked to the `Asset`. AUTO: created by AI `Asset` recognition. MANUAL: manually added."
  source: TagSource
}

"The source of a `tag`."
enum TagSource {
  MANUAL
  AUTO
}

type Copyright {
  "Asset `copyright` status."
  status: CopyrightStatus!

  "Asset `copyright` notice."
  notice: String
}

"List of possible asset `copyright` status."
enum CopyrightStatus {
  UNKNOWN
  COPYRIGHTED
  PUBLIC
}

type DateTimeRange {
  "Start `DateTime` of the range."
  from: DateTime

  "End `DateTime` of the range."
  to: DateTime
}

type License {
  "`License` id."
  id: ID!

  "`License` title."
  title: String!

  "`License` terms."
  license: String!

  "`License` is applied to new assets by default."
  addByDefault: Boolean!

  "`License` requires `User` to accept terms before download."
  requireConsensus: Boolean!
}

type MetadataValue {
  "**DEPRECATED** `MetadataValue` Id. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  id: ID! @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `User` who created the `MetadataValue`. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  creator: User! @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `DateTime` of the `MetadataValue` creation. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  createdAt: DateTime! @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `User` who last modified the `MetadataValue`. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  modifier: User @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `DateTime` of the `MetadataValue`'s last modification. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  modifiedAt: DateTime @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `MetadataField` associated to `MetadataValue`. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataField: MetadataField! @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `MetadataValue`'s value. This field will be removed. Use `CustomMetadataValueType.value` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  value: String! @deprecated(reason: "This field will be removed. Use `CustomMetadataValueType.value` instead. | Date: 2025-07-01T00:00:00.000+00:00")
}

type MetadataField {
  "**DEPRECATED** `MetadataField` Id. This field will be removed. Use `CustomMetadataProperty.id` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  id: ID! @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.id` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `User` who created the `MetadataField`. This field will be removed. Use `CustomMetadataProperty.creator` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  creator: User! @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.creator` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `DateTime` of the `MetadataField` creation. This field will be removed. Use `CustomMetadataProperty.createdAt` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  createdAt: DateTime! @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.createdAt` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `User` who last modified `MetadataField`. This field will be removed. Use `CustomMetadataProperty.modifier` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  modifier: User @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.modifier` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `DateTime` of the `MetadataField`'s last modification. This field will be removed. Use `CustomMetadataProperty.modifiedAt` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  modifiedAt: DateTime @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.modifiedAt` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `MetadataField`'s name. This field will be removed. Use `CustomMetadataProperty.name` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  label: String! @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.name` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `MetadataField`'s type. This field will be removed. Use `CustomMetadataProperty.type.name` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  type: String! @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.type.name` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Possible values for `SELECT` type `MetadataField`. This field will be removed. Use `CustomMetadataProperty.type.options` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  values: [MetadataFieldValues] @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.type.options` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Optional default value of the `MetadataField`. This field will be removed. Use `CustomMetadataProperty.defaultValue` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  defaultValue: String @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.defaultValue` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Allow multiple values in `SELECT` type `MetadataField`. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  allowMultipleValues: Boolean! @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Allow an empty value as a valid `SELECT` type `MetadataField` value. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  allowEmptyValue: Boolean! @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Allow users to search for `MetadataField` values. This field will be removed. Use `CustomMetadataProperty.isSearchable` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  isSearchable: Boolean! @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.isSearchable` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Allow users to edit `MetadataField` values. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  isEditable: Boolean! @deprecated(reason: "This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Show\/hide `MetadataField` values. This field will be removed. Use `CustomMetadataProperty.isViewable` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  isVisible: Boolean! @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.isViewable` instead. | Date: 2025-07-01T00:00:00.000+00:00")
}

type MetadataFieldValues {
  "**DEPRECATED** Value of `SELECT` type `Metadata Field`. This field will be removed. Use `CustomMetadataProperty.type.options.value` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  value: String @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.type.options.value` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Default value for `SELECT` type `Metadata Field`. This field will be removed. Use `CustomMetadataProperty.type.options.isDefault` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  default: Boolean @deprecated(reason: "This field will be removed. Use `CustomMetadataProperty.type.options.isDefault` instead. | Date: 2025-07-01T00:00:00.000+00:00")
}

"List of possible `Asset` status types."
enum AssetStatusType {
  FINISHED
  PROCESSING
  PROCESSING_FAILED
}

type AssetItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "`Asset` items list."
  items: [Asset]
}

input AssetCommentQueryInput {
  "Filter `AssetComment` by status."
  status: AssetCommentStatusFilter! = ALL
}

"Defines how the `AssetComment` list should be filtered."
enum AssetCommentStatusFilter {
  OPEN
  RESOLVED
  ALL
}

type AssetCommentItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of `AssetComment` type comments."
  items: [AssetComment]
}

"`CommentInterface` for `Comment` returnable types."
interface Comment {
  "The `Comment` identifier."
  id: ID!

  "The `User` representing the `Comment` creator."
  creator: User!

  "The `DateTime` of the `Comment` creation."
  createdAt: DateTime!

  "The last `User` to modify the `Comment`."
  modifier: User

  "The `DateTime` of the `Comment` last modification."
  modifiedAt: DateTime

  "The `Comment` message."
  content: String!
}

type AssetCommentReplyItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `AssetCommentReply`."
  items: [AssetCommentReply]
}

"Interface representing a visual `Marking` (highlighted point\/area) of an `Asset`."
interface Marking {
  "The `Marking` position in percentage relative to the top left corner of the annotated subject."
  position: MarkingPosition!

  "The `Marking` dimensions in percentage relative to the annotated subject size."
  dimensions: MarkingDimensions
}

type MarkingPosition {
  "The horizontal position of the `Marking` in percentage, in relation to the `Asset` total width."
  x: Percent!

  "The vertical position of the `Marking` in percentage, in relation to the `Asset` total height."
  y: Percent!
}

"Represents an integer or a float value between `0` and `1`, corresponding to percentage values between 0% and 100% (both inclusive)."
scalar Percent

type MarkingDimensions {
  "The width of the `Marking` area in percentage of the annotated subject total width, relative to the top left corner."
  width: Percent

  "The height of the `Marking` area in percentage of the annotated subject total height, relative to the top left corner."
  height: Percent
}

type AssetCommentUserPermissions {
  "Check if the current user can edit this `AssetComment`."
  canEdit: Boolean!

  "Check if the current user can delete this `AssetComment`."
  canDelete: Boolean!

  "Check if the current user can reply to this `AssetComment`."
  canReply: Boolean!
}

type AssetUserPermissions {
  "Check if current user has `Asset` editing permissions for a specific `Asset`."
  canEdit: Boolean!

  "Check if current user has `Asset` deleting permissions for a specific `Asset`."
  canDelete: Boolean!

  "Check if current user has `Asset` download permissions for a specific `Asset`."
  canDownload: Boolean!

  "Check if current user has `Comment` creation permissions for a specific `Asset`."
  canComment: Boolean!
}

"`CustomMetadataInterface` for `CustomMetadata` returnable types."
interface CustomMetadata {
  "`CustomMetadataProperty` details."
  property: CustomMetadataProperty!
}

"`CustomMetadataPropertyTypeInterface` for `CustomMetadataPropertyType` returnable types."
interface CustomMetadataPropertyType {
  "The `CustomMetadataProperty` type name."
  name: String!
}

"The `Any` scalar type represents any of the supported types: Null, Integer, Float, String, Boolean, Enum, Object and List."
scalar Any

type WorkflowTask {
  "**BETA** `WorkflowTask` Id."
  id: ID!

  "**BETA** A list of `User` assigned to the `WorkflowTask`."
  assignedUsers: [User]!

  "**BETA** The `Asset` linked to the `WorkflowTask`."
  asset: Asset

  "**BETA** `WorkflowTask` title."
  title: String

  "**BETA** `WorkflowTask` description."
  description: String

  "**BETA** The `WorkflowStatus` of the `WorkflowTask`."
  status: WorkflowStatus!

  "**BETA** A list of the `WorkflowChecklistItem` in the `WorkflowTask`."
  checklistItem(
    "How many `WorkflowChecklistItem` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): WorkflowChecklistItems!
}

type WorkflowStatus {
  "**BETA** `WorkflowStatus` id."
  id: ID!

  "**BETA** The name of the `WorkflowStatus`."
  name: String!

  "**BETA** The color of the `WorkflowStatus`."
  color: RgbaColor!

  "**BETA** List of `User` assigned to this `WorkflowStatus`."
  assignedUsers: [User]!

  "**BETA** A list of `WorkflowPreset` that is used to create one or more `WorkflowChecklistItem`, which are appended to a `WorkflowTask` on entering this `WorkflowState`."
  checklistPresets: [WorkflowChecklistPreset]!

  "**BETA** A list of the `WorkflowTask` in the `WorkflowStatus`."
  tasks(
    "How many `WorkflowTask` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): WorkflowStatusTaskItems!

  "**BETA** A list of `WorkflowStatusEnterRule` which needs to be satisfied before a `WorkflowTask` can enter this `WorkflowStatus`."
  enterRules: [WorkflowStatusEnterRule]!
}

type RgbaColor {
  "Red color channel value."
  red: RgbColorChannel!

  "Green color channel value."
  green: RgbColorChannel!

  "Blue color channel value."
  blue: RgbColorChannel!

  "Alpha channel value."
  alpha: Percent!
}

"The `RgbColorChannel` scalar represents an integer value between 0 and 255 (both inclusive)."
scalar RgbColorChannel

type WorkflowChecklistPreset {
  "**BETA** `WorkflowChecklistPreset` Id."
  id: ID!

  "**BETA** The content of the `WorkflowChecklistPreset`."
  content: String!

  "**BETA** The default assignee of the `WorkflowChecklistPreset`."
  assignedUser: User
}

type WorkflowStatusTaskItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `WorkflowTask`."
  items: [WorkflowTask]
}

"A rule which needs to be satisfied for a `WorkflowTask` to enter a given `WorkflowStatus`."
enum WorkflowStatusEnterRule {
  TASK_REQUIRES_ASSIGNEE
  TASK_REQUIRES_MESSAGE
}

type WorkflowChecklistItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `WorkflowChecklistItem`."
  items: [WorkflowChecklistItem]
}

type WorkflowChecklistItem {
  "**BETA** `WorkflowChecklistItem` Id."
  id: ID!

  "**BETA** The content of the `WorkflowChecklistItem`."
  content: String!

  "**BETA** The default assignee of the `WorkflowChecklistItem`."
  assignedUser: User
}

type AssetVariantItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "`AssetVariant` items list."
  items: [AssetVariant]!
}

type AssetVariant {
  "The key to identify the variant."
  key: ID!

  "Filename of the `AssetVariant` `File`."
  filename: String

  "Signed `Url` to download the original `AssetVariant` from Frontify."
  downloadUrl(
    "Download `Url` validity in days. Defaults to `1` when both `validityInDays` and `permanent` arguments are not specified."
    validityInDays: Int

    "Download `Url` validity state. When `true`, `Url` will be indefinitely valid, unless explicitly stated otherwise in the `validityInDays` argument."
    permanent: Boolean
  ): Url
}

type AssetLocation {
  "`Brand` location of the `Asset`."
  brand: AssetLocationBrand

  "`Library` location of the `Asset`."
  library: AssetLocationLibrary

  "`WorkspaceProject` location of the `Asset`."
  workspaceProject: AssetLocationWorkspaceProject

  "`Folder` location of the `Asset`."
  folder: AssetLocationFolder
}

type AssetLocationBrand {
  "`Brand` Id."
  id: ID!

  "`Brand` name."
  name: String!
}

type AssetLocationLibrary {
  "`Library` Id."
  id: ID!

  "`Library` name."
  name: String
}

type AssetLocationWorkspaceProject {
  "`WorkspaceProject` Id."
  id: ID!

  "`WorkspaceProject` name."
  name: String
}

type AssetLocationFolder {
  "`Folder` Id."
  id: ID!

  "`Folder` name."
  name: String!

  "A list of `Breadcrumb` items representing the parent folders structure for the current `Folder`."
  breadcrumbs: [Breadcrumb!]!
}

type Breadcrumb {
  "`Breadcrumb` folder id."
  id: ID

  "`Breadcrumb` folder name."
  name: String
}

type ExternalProduct {
  "`External product` Id."
  id: ID!

  "`External product` name."
  name: String!

  "`External product` externalId."
  externalId: ID

  "`External product` title."
  title: String
}

type Document implements Node & Asset {
  "`Asset` id."
  id: ID!

  "The `User` who created the `Asset`."
  creator: User!

  "`DateTime` of the `Asset` creation."
  createdAt: DateTime!

  "The `User` who last modified the `Asset`."
  modifier: User

  "`DateTime` of the `Asset` last modification."
  modifiedAt: DateTime

  "Title of the `Asset`."
  title: String!

  "Description of the `Asset`."
  description: String

  "**BETA** Alternative text for the `Asset`. Used by screen readers when the asset is not decorative."
  alternativeText: String

  "**BETA** Indicates whether the `Asset` is decorative and not meant to be read by screen readers. If true, alternative text is ignored."
  isDecorative: Boolean!

  "`Attachment` items linked to `Asset`."
  attachments: [AssetAttachment]

  "External Id of the `Asset`."
  externalId: ID

  "List of `Tag` items linked to `Asset`"
  tags: [Tag]

  "**DEPRECATED** `MetadataValue` items linked to `Asset`. This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataValues: [MetadataValue] @deprecated(reason: "This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `ExternalProduct` items linked to `Asset`. This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00"
  externalProducts: [ExternalProduct] @deprecated(reason: "This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00")

  "`Asset` copyright details."
  copyright: Copyright

  "**BETA** `Asset` will be available only during the defined `DateTime` range.When `null` it represents an unspecified start and\/or open-ended date."
  availability: DateTimeRange!

  "`Asset` available until date."
  expiresAt: DateTime

  "`License` items linked to `Asset`."
  licenses: [License]

  "Represents the Author of the `Asset`. Example: Photographer Name."
  author: String

  "Represents the conversion status of the `Asset`. Example: FINISHED."
  status: AssetStatusType!

  "Paginated list of `Asset` items related to `Asset`."
  relatedAssets(
    "How many `Asset` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "Paginated list of `AssetComment` items for `Asset`."
  comments(
    "How many `AssetComment` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "`AssetComment` query for results filtering."
    query: AssetCommentQueryInput
  ): AssetCommentItems

  "Current `User` `Asset` permissions."
  currentUserPermissions: AssetUserPermissions!

  "List of `CustomMetadataProperty` items and values associated to `Asset`."
  customMetadata: [CustomMetadata!]!

  "**BETA** The `WorkflowTask` this `Asset` is linked to."
  workflowTask: WorkflowTask

  "**BETA** `AssetVariant` items of the asset."
  variants(
    "How many `AssetVariant` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetVariantItems

  "`Location` of the `Asset`."
  location: AssetLocation!

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColor

  "Original filename of the `Asset` `File`."
  filename: String

  "Size of the `Asset` `File` in bytes."
  size: BigInt

  "Extension of the `Asset` `File`."
  extension: String!

  "Preview `Url` which has optional `width`, `height` and `page` arguments. If parameters are not specified, a `Url` without any parameters will be returned."
  previewUrl(
    "`Document` preview width value in pixels."
    width: Int

    "`Document` preview height value in pixels."
    height: Int

    "`Document` preview page number."
    page: Int
  ): Url!

  "Provides a `Url` for the custom user defined thumbnail or a system generated one when possible."
  thumbnailUrl: Url

  "**BETA** The dynamic preview `Url` of the `Asset`. Dynamically points to the latest revision's preview."
  dynamicPreviewUrl: Url

  "Signed `Url` to download the original `Document` type file."
  downloadUrl(
    "Download `Url` validity in days. Defaults to `1` when both `validityInDays` and `permanent` arguments are not specified."
    validityInDays: Int

    "Download `Url` validity state. When `true`, `Url` will be indefinitely valid, unless explicitly stated otherwise in the `validityInDays` argument."
    permanent: Boolean
  ): Url

  "`Document` focal point position. Example: `[0.4803, 0.4340]`."
  focalPoint: [Float]

  "`Document` width in pixels."
  width: Int!

  "`Document` height in pixels."
  height: Int!

  "`Document` total number of pages."
  pageCount: Int
}

type Image implements Node & Asset {
  "`Asset` id."
  id: ID!

  "The `User` who created the `Asset`."
  creator: User!

  "`DateTime` of the `Asset` creation."
  createdAt: DateTime!

  "The `User` who last modified the `Asset`."
  modifier: User

  "`DateTime` of the `Asset` last modification."
  modifiedAt: DateTime

  "Title of the `Asset`."
  title: String!

  "Description of the `Asset`."
  description: String

  "**BETA** Alternative text for the `Asset`. Used by screen readers when the asset is not decorative."
  alternativeText: String

  "**BETA** Indicates whether the `Asset` is decorative and not meant to be read by screen readers. If true, alternative text is ignored."
  isDecorative: Boolean!

  "`Attachment` items linked to `Asset`."
  attachments: [AssetAttachment]

  "External Id of the `Asset`."
  externalId: ID

  "List of `Tag` items linked to `Asset`"
  tags: [Tag]

  "**DEPRECATED** `MetadataValue` items linked to `Asset`. This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataValues: [MetadataValue] @deprecated(reason: "This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `ExternalProduct` items linked to `Asset`. This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00"
  externalProducts: [ExternalProduct] @deprecated(reason: "This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00")

  "`Asset` copyright details."
  copyright: Copyright

  "**BETA** `Asset` will be available only during the defined `DateTime` range.When `null` it represents an unspecified start and\/or open-ended date."
  availability: DateTimeRange!

  "`Asset` available until date."
  expiresAt: DateTime

  "`License` items linked to `Asset`."
  licenses: [License]

  "Represents the Author of the `Asset`. Example: Photographer Name."
  author: String

  "Represents the conversion status of the `Asset`. Example: FINISHED."
  status: AssetStatusType!

  "Paginated list of `Asset` items related to `Asset`."
  relatedAssets(
    "How many `Asset` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "Paginated list of `AssetComment` items for `Asset`."
  comments(
    "How many `AssetComment` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "`AssetComment` query for results filtering."
    query: AssetCommentQueryInput
  ): AssetCommentItems

  "Current `User` `Asset` permissions."
  currentUserPermissions: AssetUserPermissions!

  "List of `CustomMetadataProperty` items and values associated to `Asset`."
  customMetadata: [CustomMetadata!]!

  "**BETA** The `WorkflowTask` this `Asset` is linked to."
  workflowTask: WorkflowTask

  "**BETA** `AssetVariant` items of the asset."
  variants(
    "How many `AssetVariant` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetVariantItems

  "`Location` of the `Asset`."
  location: AssetLocation!

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColor

  "Original filename of the `Asset` `File`."
  filename: String

  "Size of the `Asset` `File` in bytes."
  size: BigInt

  "Extension of the `Asset` `File`."
  extension: String!

  "Preview `Url` which has optional `width` and `height` URL parameters. If parameters are not specified, `Url` without any URL parameters will be returned."
  previewUrl(
    "`Image` preview width value in pixels."
    width: Int

    "`Image` preview height value in pixels."
    height: Int
  ): Url!

  "Provides a `Url` for the custom user defined thumbnail or a system generated one when possible."
  thumbnailUrl: Url

  "**BETA** The dynamic preview `Url` of the `Asset`. Dynamically points to the latest revision's preview."
  dynamicPreviewUrl: Url

  "Signed `Url` to download the original `Image` type file."
  downloadUrl(
    "Download `Url` validity in days. Defaults to `1` when both `validityInDays` and `permanent` arguments are not specified."
    validityInDays: Int

    "Download `Url` validity state. When `true`, `Url` will be indefinitely valid, unless explicitly stated otherwise in the `validityInDays` argument."
    permanent: Boolean
  ): Url

  "`Image` focal point position. Example: `[0.4803, 0.4340]`."
  focalPoint: [Float]

  "`Image` width in pixels."
  width: Int!

  "`Image` height in pixels."
  height: Int!
}

type Video implements Node & Asset {
  "`Asset` id."
  id: ID!

  "The `User` who created the `Asset`."
  creator: User!

  "`DateTime` of the `Asset` creation."
  createdAt: DateTime!

  "The `User` who last modified the `Asset`."
  modifier: User

  "`DateTime` of the `Asset` last modification."
  modifiedAt: DateTime

  "Title of the `Asset`."
  title: String!

  "Description of the `Asset`."
  description: String

  "**BETA** Alternative text for the `Asset`. Used by screen readers when the asset is not decorative."
  alternativeText: String

  "**BETA** Indicates whether the `Asset` is decorative and not meant to be read by screen readers. If true, alternative text is ignored."
  isDecorative: Boolean!

  "`Attachment` items linked to `Asset`."
  attachments: [AssetAttachment]

  "External Id of the `Asset`."
  externalId: ID

  "List of `Tag` items linked to `Asset`"
  tags: [Tag]

  "**DEPRECATED** `MetadataValue` items linked to `Asset`. This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataValues: [MetadataValue] @deprecated(reason: "This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `ExternalProduct` items linked to `Asset`. This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00"
  externalProducts: [ExternalProduct] @deprecated(reason: "This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00")

  "`Asset` copyright details."
  copyright: Copyright

  "**BETA** `Asset` will be available only during the defined `DateTime` range.When `null` it represents an unspecified start and\/or open-ended date."
  availability: DateTimeRange!

  "`Asset` available until date."
  expiresAt: DateTime

  "`License` items linked to `Asset`."
  licenses: [License]

  "Represents the Author of the `Asset`. Example: Photographer Name."
  author: String

  "Represents the conversion status of the `Asset`. Example: FINISHED."
  status: AssetStatusType!

  "Paginated list of `Asset` items related to `Asset`."
  relatedAssets(
    "How many `Asset` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "Paginated list of `AssetComment` items for `Asset`."
  comments(
    "How many `AssetComment` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "`AssetComment` query for results filtering."
    query: AssetCommentQueryInput
  ): AssetCommentItems

  "Current `User` `Asset` permissions."
  currentUserPermissions: AssetUserPermissions!

  "List of `CustomMetadataProperty` items and values associated to `Asset`."
  customMetadata: [CustomMetadata!]!

  "**BETA** The `WorkflowTask` this `Asset` is linked to."
  workflowTask: WorkflowTask

  "**BETA** `AssetVariant` items of the asset."
  variants(
    "How many `AssetVariant` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetVariantItems

  "`Location` of the `Asset`."
  location: AssetLocation!

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColor

  "Original filename of the `Asset` `File`."
  filename: String

  "Size of the `Asset` `File` in bytes."
  size: BigInt

  "Extension of the `Asset` `File`."
  extension: String!

  "Preview `Url` of converted `Video` in mp4 format."
  previewUrl(
    "`Video` preview width value in pixels."
    width: Int

    "`Video` preview height value in pixels."
    height: Int
  ): Url!

  "Provides a `Url` for the custom user defined thumbnail or a system generated one when possible."
  thumbnailUrl: Url

  "**BETA** The dynamic preview `Url` of the `Asset`. Dynamically points to the latest revision's preview."
  dynamicPreviewUrl: Url

  "Signed `Url` to download the original `Video` type file."
  downloadUrl(
    "Download `Url` validity in days. Defaults to `1` when both `validityInDays` and `permanent` arguments are not specified."
    validityInDays: Int

    "Download `Url` validity state. When `true`, `Url` will be indefinitely valid, unless explicitly stated otherwise in the `validityInDays` argument."
    permanent: Boolean
  ): Url

  "`Video` width in pixels."
  width: Int!

  "`Video` height in pixels."
  height: Int!

  "`Video` duration in seconds."
  duration: Float!

  "`Video` bitrate in bits per second."
  bitrate: Int!
}

type File implements Node & Asset {
  "`Asset` id."
  id: ID!

  "The `User` who created the `Asset`."
  creator: User!

  "`DateTime` of the `Asset` creation."
  createdAt: DateTime!

  "The `User` who last modified the `Asset`."
  modifier: User

  "`DateTime` of the `Asset` last modification."
  modifiedAt: DateTime

  "Title of the `Asset`."
  title: String!

  "Description of the `Asset`."
  description: String

  "**BETA** Alternative text for the `Asset`. Used by screen readers when the asset is not decorative."
  alternativeText: String

  "**BETA** Indicates whether the `Asset` is decorative and not meant to be read by screen readers. If true, alternative text is ignored."
  isDecorative: Boolean!

  "`Attachment` items linked to `Asset`."
  attachments: [AssetAttachment]

  "External Id of the `Asset`."
  externalId: ID

  "List of `Tag` items linked to `Asset`"
  tags: [Tag]

  "**DEPRECATED** `MetadataValue` items linked to `Asset`. This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataValues: [MetadataValue] @deprecated(reason: "This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `ExternalProduct` items linked to `Asset`. This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00"
  externalProducts: [ExternalProduct] @deprecated(reason: "This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00")

  "`Asset` copyright details."
  copyright: Copyright

  "**BETA** `Asset` will be available only during the defined `DateTime` range.When `null` it represents an unspecified start and\/or open-ended date."
  availability: DateTimeRange!

  "`Asset` available until date."
  expiresAt: DateTime

  "`License` items linked to `Asset`."
  licenses: [License]

  "Represents the Author of the `Asset`. Example: Photographer Name."
  author: String

  "Represents the conversion status of the `Asset`. Example: FINISHED."
  status: AssetStatusType!

  "Paginated list of `Asset` items related to `Asset`."
  relatedAssets(
    "How many `Asset` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "Paginated list of `AssetComment` items for `Asset`."
  comments(
    "How many `AssetComment` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "`AssetComment` query for results filtering."
    query: AssetCommentQueryInput
  ): AssetCommentItems

  "Current `User` `Asset` permissions."
  currentUserPermissions: AssetUserPermissions!

  "List of `CustomMetadataProperty` items and values associated to `Asset`."
  customMetadata: [CustomMetadata!]!

  "**BETA** The `WorkflowTask` this `Asset` is linked to."
  workflowTask: WorkflowTask

  "**BETA** `AssetVariant` items of the asset."
  variants(
    "How many `AssetVariant` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetVariantItems

  "`Location` of the `Asset`."
  location: AssetLocation!

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColor

  "Original filename of the `Asset` `File`."
  filename: String

  "Size of the `Asset` `File` in bytes."
  size: BigInt

  "Extension of the `Asset` `File`."
  extension: String!

  "`File` type icon in `svg` format."
  previewUrl: Url!

  "Provides a `Url` for the custom user defined thumbnail or a system generated one when possible."
  thumbnailUrl: Url

  "**BETA** The dynamic preview `Url` of the `Asset`. Dynamically points to the latest revision's preview."
  dynamicPreviewUrl: Url

  "Signed `Url` to download the original `File` type file."
  downloadUrl(
    "Download `Url` validity in days. Defaults to `1` when both `validityInDays` and `permanent` arguments are not specified."
    validityInDays: Int

    "Download `Url` validity state. When `true`, `Url` will be indefinitely valid, unless explicitly stated otherwise in the `validityInDays` argument."
    permanent: Boolean
  ): Url
}

type EmbeddedContent implements Node & Asset {
  "`Asset` id."
  id: ID!

  "The `User` who created the `Asset`."
  creator: User!

  "`DateTime` of the `Asset` creation."
  createdAt: DateTime!

  "The `User` who last modified the `Asset`."
  modifier: User

  "`DateTime` of the `Asset` last modification."
  modifiedAt: DateTime

  "Title of the `Asset`."
  title: String!

  "Description of the `Asset`."
  description: String

  "**BETA** Alternative text for the `Asset`. Used by screen readers when the asset is not decorative."
  alternativeText: String

  "**BETA** Indicates whether the `Asset` is decorative and not meant to be read by screen readers. If true, alternative text is ignored."
  isDecorative: Boolean!

  "`Attachment` items linked to `Asset`."
  attachments: [AssetAttachment]

  "External Id of the `Asset`."
  externalId: ID

  "List of `Tag` items linked to `Asset`"
  tags: [Tag]

  "**DEPRECATED** `MetadataValue` items linked to `Asset`. This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataValues: [MetadataValue] @deprecated(reason: "This field will be removed. Use `customMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**DEPRECATED** `ExternalProduct` items linked to `Asset`. This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00"
  externalProducts: [ExternalProduct] @deprecated(reason: "This field will be removed. | Date: 2025-01-01T00:00:00.000+00:00")

  "`Asset` copyright details."
  copyright: Copyright

  "**BETA** `Asset` will be available only during the defined `DateTime` range.When `null` it represents an unspecified start and\/or open-ended date."
  availability: DateTimeRange!

  "`Asset` available until date."
  expiresAt: DateTime

  "`License` items linked to `Asset`."
  licenses: [License]

  "Represents the Author of the `Asset`. Example: Photographer Name."
  author: String

  "Represents the conversion status of the `Asset`. Example: FINISHED."
  status: AssetStatusType!

  "Paginated list of `Asset` items related to `Asset`."
  relatedAssets(
    "How many `Asset` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "Paginated list of `AssetComment` items for `Asset`."
  comments(
    "How many `AssetComment` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "`AssetComment` query for results filtering."
    query: AssetCommentQueryInput
  ): AssetCommentItems

  "Current `User` `Asset` permissions."
  currentUserPermissions: AssetUserPermissions!

  "List of `CustomMetadataProperty` items and values associated to `Asset`."
  customMetadata: [CustomMetadata!]!

  "**BETA** The `WorkflowTask` this `Asset` is linked to."
  workflowTask: WorkflowTask

  "**BETA** `AssetVariant` items of the asset."
  variants(
    "How many `AssetVariant` items to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetVariantItems

  "`Location` of the `Asset`."
  location: AssetLocation!

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColor

  "Preview of the embedded content. If the preview is not available, an svg icon will be returned."
  previewUrl: Url!

  "Provides a `Url` for the custom user defined thumbnail or a system generated one when possible."
  thumbnailUrl: Url
}

type AssetAttachment implements Node & Attachment {
  "`Attachment` Id."
  id: ID!

  "The `creator` is the `User` who created this `Attachment`."
  creator: User!

  "`DateTime` of the `Attachment` creation."
  createdAt: DateTime!

  "The `modifier` is the `User` who last modified this `Attachment`."
  modifier: User

  "`DateTime` of the `Attachment`last modification."
  modifiedAt: DateTime

  "Name of the `Attachment`."
  name: String

  "Filename of the `Attachment` `File`."
  filename: String

  "Mediatype (MIME) of the `Attachment`."
  type: String

  "External Id of the `Attachment`."
  externalId: ID

  "Extension of the `Attachment` `File`."
  extension: String

  "Size of the `Attachment` `File` in bytes."
  size: BigInt

  "Signed `Url` to download the original `AssetAttachment` from Frontify."
  downloadUrl(
    "Download `Url` validity in days. Defaults to `1` when both `validityInDays` and `permanent` arguments are not specified."
    validityInDays: Int

    "Download `Url` validity state. When `true`, `Url` will be indefinitely valid, unless explicitly stated otherwise in the `validityInDays` argument."
    permanent: Boolean
  ): Url
}

type AssetComment implements Node & Comment {
  "`AssetComment` id."
  id: ID!

  "`User` who created the `AssetComment`."
  creator: User!

  "`DateTime` of the `AssetComment`'s creation."
  createdAt: DateTime!

  "`User` who last modified the `AssetComment`."
  modifier: User

  "`DateTime` of the `AssetComment`'s last modification."
  modifiedAt: DateTime

  "The content of the `AssetComment`. Contains `User` mentions in the format `@[user:USER_ID].`"
  content: String!

  "Mentioned `User` list in the `content` field."
  mentionedUsers: [User]!

  "Indicates if an `AssetComment` is resolved or not."
  isResolved: Boolean!

  "`AssetComment`'s `AssetCommentReplyItems` list."
  replies(
    "How many `AssetCommentReplyItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetCommentReplyItems!

  "The `AssetComment` `Marking` if it exists."
  marking: Marking

  "`AssetComment` permissions of the current `User`."
  currentUserPermissions: AssetCommentUserPermissions!
}

type AssetCommentReply implements Comment {
  "The id of the current `AssetCommentReply`."
  id: ID!

  "The `User` representing the creator."
  creator: User!

  "The `DateTime` of creation."
  createdAt: DateTime!

  "The `User` representing the last modifier."
  modifier: User

  "The `DateTime` of the last modification."
  modifiedAt: DateTime

  "The content of the `AssetCommentReply`. Contains `User` mentions in the format `@[user:USER_ID].`"
  content: String!

  "Mentioned `User` list in the `content` field."
  mentionedUsers: [User]!
}

type CustomMetadataValue implements CustomMetadata {
  "`CustomMetadataProperty` details."
  property: CustomMetadataProperty!

  "`CustomMetadataProperty` value. Returns an object with `optionId` and `text` property values (for `SELECT` type only) or a string for other `CustomMetadataProperty` single value items."
  value: Any
}

type CustomMetadataValues implements CustomMetadata {
  "`CustomMetadataProperty` details."
  property: CustomMetadataProperty!

  "`CustomMetadataProperty` values. Returns an empty list or a list of objects with `optionId` and `text` property values (for `MULTISELECT` type only)."
  values: [Any]!
}

type CustomMetadataPropertySelectValueTypeDependencyTypeEquals implements CustomMetadataPropertyDependency {
  "`CustomMetadataPropertyDependency` type."
  type: String!

  "The dependee `CustomMetadataProperty` Id."
  propertyId: ID!

  "`CustomMetadataPropertyOption` Id."
  propertyOptionId: ID!
}

"`CustomMetadataPropertyDependencyInterface` for `CustomMetadataPropertyDependency` returnable types."
interface CustomMetadataPropertyDependency {
  "The `CustomMetadataPropertyDependency` type."
  type: String!

  "The dependee `CustomMetadataProperty` Id."
  propertyId: ID!
}

type CustomMetadataPropertySelectValueTypeDependencyTypeOneOf implements CustomMetadataPropertyDependency {
  "`CustomMetadataPropertyDependency` type."
  type: String!

  "The dependee `CustomMetadataProperty` Id."
  propertyId: ID!

  "`CustomMetadataPropertyOption` property option ids."
  propertyOptionIds: [ID]!
}

type CustomMetadataPropertyValueTypeDependencyTypeFilled implements CustomMetadataPropertyDependency {
  "`CustomMetadataPropertyDependency` type."
  type: String!

  "The dependee `CustomMetadataProperty` Id."
  propertyId: ID!
}

type CustomMetadataPropertyTypeText implements CustomMetadataPropertyType {
  "The `CustomMetadataProperty` type name."
  name: String!
}

type CustomMetadataPropertyTypeLongText implements CustomMetadataPropertyType {
  "The `CustomMetadataProperty` type name."
  name: String!
}

type CustomMetadataPropertyTypeUrl implements CustomMetadataPropertyType {
  "The `CustomMetadataProperty` type name."
  name: String!
}

type CustomMetadataPropertyTypeNumber implements CustomMetadataPropertyType {
  "The `CustomMetadataProperty` type name."
  name: String!
}

type CustomMetadataPropertyTypeDate implements CustomMetadataPropertyType {
  "The `CustomMetadataProperty` type name."
  name: String!
}

type CustomMetadataPropertyTypeSelect implements CustomMetadataPropertyType {
  "The `CustomMetadataProperty` type name."
  name: String!

  "`SELECT` type `CustomMetadataProperty` options."
  options: [CustomMetadataPropertyOption]!
}

type CustomMetadataPropertyOption {
  "`CustomMetadataPropertyOption` Id."
  id: ID!

  "`CustomMetadataPropertyOption` value."
  value: String!

  "Indicates if a `CustomMetadataPropertyOption` value is set to newly updated `Assets` by default."
  isDefault: Boolean!
}

type CustomMetadataPropertyTypeMultiSelect implements CustomMetadataPropertyType {
  "The `CustomMetadataProperty` type name."
  name: String!

  "`MULTISELECT` type `CustomMetadataProperty` options."
  options: [CustomMetadataPropertyOption]!
}

type CustomMetadataPropertyTextValueType implements CustomMetadataPropertyValueType {
  "`CustomMetadataPropertyValueType` property type."
  propertyType: String!
}

"`CustomMetadataPropertyValueTypeInterface` for `CustomMetadataPropertyValueType` returnable types."
interface CustomMetadataPropertyValueType {
  "The `CustomMetadataPropertyValueType` property type."
  propertyType: String!
}

type CustomMetadataPropertyLongTextValueType implements CustomMetadataPropertyValueType {
  "`CustomMetadataPropertyValueType` property type."
  propertyType: String!
}

type CustomMetadataPropertyUrlValueType implements CustomMetadataPropertyValueType {
  "`CustomMetadataPropertyValueType` property type."
  propertyType: String!
}

type CustomMetadataPropertyNumberValueType implements CustomMetadataPropertyValueType {
  "`CustomMetadataPropertyValueType` property type."
  propertyType: String!
}

type CustomMetadataPropertyDateValueType implements CustomMetadataPropertyValueType {
  "`CustomMetadataPropertyValueType` property type."
  propertyType: String!
}

type CustomMetadataPropertySelectValueType implements CustomMetadataPropertyValueType {
  "`CustomMetadataPropertyValueType` property type."
  propertyType: String!

  "`SelectPropertyValueType` options."
  options: [CustomMetadataPropertyOption]!
}

type CustomMetadataPropertyMultiSelectValueType implements CustomMetadataPropertyValueType {
  "`CustomMetadataPropertyValueType` property type."
  propertyType: String!

  "`MultiSelectPropertyValueType` options."
  options: [CustomMetadataPropertyOption]!
}

type SubFolder implements Node & Folder {
  "`SubFolder` Id."
  id: ID!

  "`SubFolder` name."
  name: String!

  "The `User` who created the `SubFolder`."
  creator: User!

  "`DateTime` of the `SubFolder` creation."
  createdAt: DateTime!

  "The `User` who last modified the `SubFolder`."
  modifier: User

  "`DateTime` of the last `SubFolder` modification."
  modifiedAt: DateTime

  "A list of `Breadcrumb` items representing the parent folders structure for the current `SubFolder`."
  breadcrumbs: [Breadcrumb!]!

  "**DEPRECATED** The `SubFolderItems` of the current `SubFolder`. This field will be removed. Use `folders` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  subFolders(
    "How many `SubFolderItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `SubFolderItems` listing page number."
    page: Int = 1
  ): SubFolderItems! @deprecated(reason: "This field will be removed. Use `folders` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "The `FolderItems` of the current `Folder`."
  folders(
    "How many `FolderItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `FolderItems` listing page number."
    page: Int = 1
  ): FolderItems!

  "The `AssetItems` in the current `SubFolder`."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `AssetItems` listing page number."
    page: Int = 1

    "**BETA** Define search criteria for the `AssetItems` in the `SubFolder`."
    query: FolderAssetQueryInput
  ): AssetItems!
}

"`FolderInterface` for `Folder` returnable types."
interface Folder {
  "`Folder` Id."
  id: ID!

  "`Folder` name."
  name: String!

  "The `User` who created the `Folder`."
  creator: User!

  "`DateTime` of the `Folder` creation."
  createdAt: DateTime!

  "The `User` who last modified the `Folder`."
  modifier: User

  "`DateTime` of the last `Folder` modification."
  modifiedAt: DateTime

  "A list of `Breadcrumb` items representing the parent folders structure for the current `SubFolder`."
  breadcrumbs: [Breadcrumb!]!

  "**DEPRECATED** The `SubFolderItems` of the current `Library`\/`Workspace`\/`SubFolder`. This field will be removed. Use `folders` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  subFolders(
    "How many `SubFolderItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `SubFolderItems` listing page number."
    page: Int = 1
  ): SubFolderItems! @deprecated(reason: "This field will be removed. Use `folders` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "The `FolderItems` of the current `Library`\/`Workspace`\/`Folder`."
  folders(
    "How many `FolderItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `FolderItems` listing page number."
    page: Int = 1
  ): FolderItems!

  "The `AssetItems` in the current `Library`\/`Workspace`\/`Folder`."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `AssetItems` listing page number."
    page: Int = 1

    "**BETA** Define search criteria for the `AssetItems` in the `Library`\/`Workspace` or `Folder`."
    query: FolderAssetQueryInput
  ): AssetItems!
}

type SubFolderItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `SubFolder`"
  items: [SubFolder]
}

type FolderItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `Folder`"
  items: [Folder]
}

input FolderAssetQueryInput {
  "**BETA** Sort order of matched results."
  sortBy: AssetQueryFilterSortType
}

"Search sorting option. Defines how the search results should be sorted."
enum AssetQueryFilterSortType {
  "Sorts the results by the relevance (query score)."
  RELEVANCE

  "Sorts the results by the newest `Assets`."
  NEWEST

  "Sorts the results by the oldest `Assets`."
  OLDEST

  "Sorts the results ascending by the title of the `Assets`."
  TITLE_ASCENDING

  "sorts the results descending by the title of the `Assets`."
  TITLE_DESCENDING
}

type MediaLibrary implements Node & Library {
  "`Library`\/`Workspace` Id."
  id: ID!

  "`Library`\/`Workspace` name."
  name: String!

  "`Library`\/`Workspace` color."
  color: RgbaColor

  "**DEPRECATED** Amount of `Assets` contained in the `Library`\/`Workspace`. This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00"
  assetCount: Int @deprecated(reason: "This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00")

  "Search or list `Assets` in the `Library`\/`Workspace`."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Define search criteria for `Assets` in the `Library`\/`Workspace`."
    query: AssetQueryInput
  ): AssetItems!

  "`Library`\/`Workspace` `License` items list."
  licenses: [License]

  "**DEPRECATED** `Library`\/`Workspace` `MetadataField` items list. This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataFields: [MetadataField] @deprecated(reason: "This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**BETA** The `Workflow` belonging to the given `Library`\/`Workspace`."
  workflow: Workflow!

  "Browse the `Library` `SubFolderItems` and `AssetItems`."
  browse: LibraryRootFolder!

  "`Library` collaborators."
  collaborators: LibraryCollaborators

  "`Library` permissions of the current `User`."
  currentUserPermissions: LibraryUserPermissions!

  "Retrieve list of all `CustomMetadataProperty` items belonging to `Library`."
  customMetadataProperties: [CustomMetadataProperty!]!

  "`Library` `Collection` items list."
  collections(
    "How many `CollectionItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): CollectionItems!

  "**BETA** List of `AssetSubmissionRequests` available for a `Library`."
  assetSubmissionRequests: [AssetSubmissionRequest!]!
}

"`LibraryInterface` for `Library` returnable types."
interface Library {
  "`Library` Id."
  id: ID!

  "`Library` name."
  name: String!

  "`Library` color."
  color: RgbaColor

  "**DEPRECATED** Amount of `Assets` contained in this `Library`. This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00"
  assetCount: Int @deprecated(reason: "This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00")

  "**DEPRECATED** Retrieve list of all `MetadataFields` belonging to this `Library`. This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataFields: [MetadataField] @deprecated(reason: "This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "Search or list `Assets` in this `Library`."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Define search criteria for `Assets` in this `Library`."
    query: AssetQueryInput
  ): AssetItems!

  "Retrieve list of all `Licenses` belonging to this `Library`."
  licenses: [License]

  "List `Collection` type items within a `Library`."
  collections(
    "How many `CollectionItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): CollectionItems!

  "Browse the `Library`'s `SubFolderItems` and `AssetItems`."
  browse: LibraryRootFolder!

  "`Library` collaborators."
  collaborators: LibraryCollaborators

  "Check current `User` permissions in a specific `Library`."
  currentUserPermissions: LibraryUserPermissions!

  "**BETA** The `Workflow` belonging to the given `Library`."
  workflow: Workflow!

  "List of `CustomMetadataProperty` items belonging to a `Library`."
  customMetadataProperties: [CustomMetadataProperty!]!

  "**BETA** List of `AssetSubmissionRequests` available for a `Library`."
  assetSubmissionRequests: [AssetSubmissionRequest!]!
}

input AssetQueryInput {
  "Use filters to reduce the set of matched `Asset` items by complex filtering."
  filter: AssetQueryFilterInput

  "Limit the result set to a specific `Folder` of this `Library`."
  inFolder: AssetQueryInFolderInput

  "Sort set of the matched `AssetItems`."
  sortBy: AssetQueryFilterSortType

  "Limit the result set by the externalId of an `Asset`."
  externalId: ID

  "Limit the result set by the search term."
  search: String

  "**DEPRECATED** Filter the `Asset` types present in the result set. This field will be removed. Use `types` instead. | Date: 2022-07-01T00:00:00.000+00:00"
  type: [AssetType]

  "Limit the result set by the `Asset` types."
  types: [AssetType]
}

input AssetQueryFilterInput {
  "The Asset must pass **all conditions** in this List to be present in the result set."
  andConditions: [AssetQueryFilterConditionInput]

  "The Asset must pass **at least one condition** in this List to be present in the result set."
  orConditions: [AssetQueryFilterConditionInput]
}

input AssetQueryFilterConditionInput {
  "Defines which property of the `Asset` is compared to the provided value."
  type: ConditionType!

  "Defines how the value of the `Asset` is compared to the provided value."
  operator: ConditionOperator = IS

  "The value which is compared against the property of the `Asset`."
  value: String!

  "**REQUIRED** for type `METADATA_VALUE` to identify which metadata field it is compared against. You can find all available `metadataFields` on the project."
  metadataFieldId: ID

  "**REQUIRED** for type `CUSTOM_METADATA_VALUE` to identify which `CustomMetadataProperty` it is compared against. You can find all available `CustomMetadataProperty` on the project."
  customMetadataPropertyId: ID
}

"""
Condition types. A Condition defines which field value of the `Asset` is compared against a given value.
We currently support 4 different kinds of Conditions on `Assets`:
- **TAG**: Refers to a tag of the `Asset`.
- **METADATA_VALUE**: Refers to a value of a custom `MetadataField` of an `Asset`.
- **CUSTOM_METADATA_VALUE**: Refers to a value of a `CustomMetadata` of an `Asset`.
- **EXTERNAL_ID**: Refers to the `externalId` assigned to the `Asset`.
- **FILE_EXTENSION**: Refers to the file extension of an `Asset`.
"""
enum ConditionType {
  METADATA_VALUE
  CUSTOM_METADATA_VALUE
  EXTERNAL_ID
  TAG
  FILE_EXTENSION
}

"""
Condition operators. Defines how the value of the `Asset` is compared to the provided value.
Supported Operators:
- **IS**: equals to the provided value.
- **IS_NOT**: is not equal to provided value.
"""
enum ConditionOperator {
  IS
  IS_NOT
}

input AssetQueryInFolderInput {
  "`Folder` Id."
  id: ID!
}

"The type of an `asset`."
enum AssetType {
  AUDIO
  DOCUMENT
  FILE
  IMAGE
  VIDEO
}

type CollectionItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of `Collection` items."
  items: [Collection]
}

type CollectionUserPermissions {
  "Check if the current user can add `Assets` in this `Collection`."
  canAddAssets: Boolean!

  "Check if the current user can remove `Assets` from this `Collection`."
  canRemoveAssets: Boolean!
}

type LibraryRootFolder {
  "**DEPRECATED** The `SubFolderItems` of the current `Library`\/`Workspace`. This field will be removed. Use `folders` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  subFolders(
    "How many `SubFolderItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `SubFolderItems` listing page number."
    page: Int = 1
  ): SubFolderItems! @deprecated(reason: "This field will be removed. Use `folders` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "The `FolderItems` of the current `Library`\/`Workspace`."
  folders(
    "How many `FolderItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `FolderItems` listing page number."
    page: Int = 1
  ): FolderItems!

  "`Library`\/`Workspace`'s `AssetItems` list."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `AssetItems` listing page number."
    page: Int = 1

    "**BETA** Define search criteria for the `AssetItems` in the `Library`\/`Workspace`."
    query: FolderAssetQueryInput
  ): AssetItems!
}

type LibraryCollaborators {
  "`LibraryCollaboratorUserItems` list."
  users(
    "How many `LibraryCollaboratorUserItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): LibraryCollaboratorUserItems!
}

type LibraryCollaboratorUserItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of `User` items that have lowest required permissions to collaborate on a `Library`."
  items: [User]!

  "**BETA** List of `LibraryCollaboratorUserEdge` edges."
  edges: [LibraryCollaboratorUserEdge!]!
}

type LibraryCollaboratorUserEdge {
  "`User` that has the least required permissions to collaborate on a `Library`."
  node: User!

  "`User` role in the `Library`."
  role: String!
}

type LibraryUserPermissions {
  "Check if current `User` has `Asset` creation permissions in a specific `Library`."
  canCreateAssets: Boolean!

  "Check if current `User` has `Collaborator` view permissions in a specific `Library`."
  canViewCollaborators: Boolean!

  "Check if current `User` has `Collection` creation permissions in a specific `Library`."
  canCreateCollections: Boolean!
}

type Workflow {
  "**BETA** `Workflow` Id."
  id: ID!

  "**BETA** Multiple statuses define a `Workflow`. They represent a line\/row in the Kanban board of the current `Workflow`."
  statuses: [WorkflowStatus]!
}

type AssetSubmissionRequest {
  "`AssetSubmissionRequest` Id."
  id: ID!

  "The `User` who created the `AssetSubmissionRequest`."
  creator: User!

  "`DateTime` of the `AssetSubmissionRequest` creation."
  createdAt: DateTime!

  "The `User` who last modified the `AssetSubmissionRequest`."
  modifier: User

  "`DateTime` of the `AssetSubmissionRequest` last modification."
  modifiedAt: DateTime

  "`AssetSubmissionRequest` destination `Project` id."
  projectId: ID!

  "`AssetSubmissionRequest` title."
  title: String!

  "`AssetSubmissionRequest` description."
  description: String!

  "`AssetSubmissionRequest` configuration settings."
  configuration: Json
}

"The `Json` scalar type represents valid JSON returnable types."
scalar Json

type IconLibrary implements Node & Library {
  "`Library`\/`Workspace` Id."
  id: ID!

  "`Library`\/`Workspace` name."
  name: String!

  "`Library`\/`Workspace` color."
  color: RgbaColor

  "**DEPRECATED** Amount of `Assets` contained in the `Library`\/`Workspace`. This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00"
  assetCount: Int @deprecated(reason: "This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00")

  "Search or list `Assets` in the `Library`\/`Workspace`."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Define search criteria for `Assets` in the `Library`\/`Workspace`."
    query: AssetQueryInput
  ): AssetItems!

  "`Library`\/`Workspace` `License` items list."
  licenses: [License]

  "**DEPRECATED** `Library`\/`Workspace` `MetadataField` items list. This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataFields: [MetadataField] @deprecated(reason: "This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**BETA** The `Workflow` belonging to the given `Library`\/`Workspace`."
  workflow: Workflow!

  "Browse the `Library` `SubFolderItems` and `AssetItems`."
  browse: LibraryRootFolder!

  "`Library` collaborators."
  collaborators: LibraryCollaborators

  "`Library` permissions of the current `User`."
  currentUserPermissions: LibraryUserPermissions!

  "Retrieve list of all `CustomMetadataProperty` items belonging to `Library`."
  customMetadataProperties: [CustomMetadataProperty!]!

  "`Library` `Collection` items list."
  collections(
    "How many `CollectionItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): CollectionItems!

  "**BETA** List of `AssetSubmissionRequests` available for a `Library`."
  assetSubmissionRequests: [AssetSubmissionRequest!]!
}

type LogoLibrary implements Node & Library {
  "`Library`\/`Workspace` Id."
  id: ID!

  "`Library`\/`Workspace` name."
  name: String!

  "`Library`\/`Workspace` color."
  color: RgbaColor

  "**DEPRECATED** Amount of `Assets` contained in the `Library`\/`Workspace`. This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00"
  assetCount: Int @deprecated(reason: "This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00")

  "Search or list `Assets` in the `Library`\/`Workspace`."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Define search criteria for `Assets` in the `Library`\/`Workspace`."
    query: AssetQueryInput
  ): AssetItems!

  "`Library`\/`Workspace` `License` items list."
  licenses: [License]

  "**DEPRECATED** `Library`\/`Workspace` `MetadataField` items list. This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataFields: [MetadataField] @deprecated(reason: "This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**BETA** The `Workflow` belonging to the given `Library`\/`Workspace`."
  workflow: Workflow!

  "Browse the `Library` `SubFolderItems` and `AssetItems`."
  browse: LibraryRootFolder!

  "`Library` collaborators."
  collaborators: LibraryCollaborators

  "`Library` permissions of the current `User`."
  currentUserPermissions: LibraryUserPermissions!

  "Retrieve list of all `CustomMetadataProperty` items belonging to `Library`."
  customMetadataProperties: [CustomMetadataProperty!]!

  "`Library` `Collection` items list."
  collections(
    "How many `CollectionItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): CollectionItems!

  "**BETA** List of `AssetSubmissionRequests` available for a `Library`."
  assetSubmissionRequests: [AssetSubmissionRequest!]!
}

type DocumentLibrary implements Node & Library {
  "`Library`\/`Workspace` Id."
  id: ID!

  "`Library`\/`Workspace` name."
  name: String!

  "`Library`\/`Workspace` color."
  color: RgbaColor

  "**DEPRECATED** Amount of `Assets` contained in the `Library`\/`Workspace`. This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00"
  assetCount: Int @deprecated(reason: "This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00")

  "Search or list `Assets` in the `Library`\/`Workspace`."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Define search criteria for `Assets` in the `Library`\/`Workspace`."
    query: AssetQueryInput
  ): AssetItems!

  "`Library`\/`Workspace` `License` items list."
  licenses: [License]

  "**DEPRECATED** `Library`\/`Workspace` `MetadataField` items list. This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataFields: [MetadataField] @deprecated(reason: "This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**BETA** The `Workflow` belonging to the given `Library`\/`Workspace`."
  workflow: Workflow!

  "Browse the `Library` `SubFolderItems` and `AssetItems`."
  browse: LibraryRootFolder!

  "`Library` collaborators."
  collaborators: LibraryCollaborators

  "`Library` permissions of the current `User`."
  currentUserPermissions: LibraryUserPermissions!

  "Retrieve list of all `CustomMetadataProperty` items belonging to `Library`."
  customMetadataProperties: [CustomMetadataProperty!]!

  "`Library` `Collection` items list."
  collections(
    "How many `CollectionItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): CollectionItems!

  "**BETA** List of `AssetSubmissionRequests` available for a `Library`."
  assetSubmissionRequests: [AssetSubmissionRequest!]!
}

type SimpleMarking implements Marking {
  "The `Marking` position in percent relative to the top left corner of the `Asset`."
  position: MarkingPosition!

  "The `Marking` dimensions in percent of `Asset` dimensions."
  dimensions: MarkingDimensions
}

type MultiPageMarking implements Marking {
  "The `Marking` position in percent relative to the top left corner of the `Asset`."
  position: MarkingPosition!

  "The `Marking` dimensions in percent of `Asset` dimensions."
  dimensions: MarkingDimensions

  "The `Asset` page where the `Marking` is set."
  page: Int
}

type VideoMarking implements Marking {
  "The `Marking` position in percent relative to the top left corner of the `Asset`."
  position: MarkingPosition!

  "The `Marking` dimensions in percent of `Asset` dimensions."
  dimensions: MarkingDimensions

  "The timeframe of the `Marking`. Applicable to `Video` type `Asset` items only."
  timeframe: MarkingTimeframe
}

type MarkingTimeframe {
  "The start of the `Marking` area in percentage of total video length."
  start: Percent

  "The end of the `Marking` area in percentage of total video length."
  end: Percent
}

type Account implements Node {
  "`Account` Id."
  id: ID!

  "List and search `UserItems`."
  users(
    "How many `UserItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): UserItems

  "List and search `UserGroupItems`."
  userGroups(
    "How many `UserGroupItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): UserGroupItems

  "**BETA** List and search `AccountSearch` item(s)."
  search(
    "How many `AccountSearch` item(s) to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Define search criteria for the `AccountSearch` item(s)."
    query: AccountQueryInput
  ): AccountSearchItems
}

type UserItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "`User` items list."
  items: [User]
}

type UserGroupItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `UserGroup`."
  items: [UserGroup]
}

input AccountQueryInput {
  "Search term used to retrieve matched results."
  term: String

  "Sort order of matched results."
  sortBy: AccountQuerySortByInput = RELEVANCE

  "Use filters to reduce the set of matched results."
  filter: AccountQueryFilterInput
}

"Search sorting option. Defines how the search results should be sorted."
enum AccountQuerySortByInput {
  "Sort the results by relevance."
  RELEVANCE

  "Sort the results by newest."
  NEWEST

  "Sort the results by oldest."
  OLDEST
}

input AccountQueryFilterInput {
  "Specify the sources to search in."
  sources: [AccountQuerySourceInput!]
}

input AccountQuerySourceInput {
  "Specify the source type to search in."
  type: AccountQuerySourceTypeInput!

  "Specify the Ids of the source type you want to search in. If no Ids are specified, a search will be performed on all accessible Ids of the type."
  ids: [ID!]
}

"Search sources option. Defines the location of the search results."
enum AccountQuerySourceTypeInput {
  "Search for the results in `Libraries`."
  LIBRARIES

  "Search for the results in the `WorkspaceProjects`."
  WORKSPACE_PROJECTS

  "Search for the results in the `LibraryPages`."
  LIBRARY_PAGES
}

type AccountSearchItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of `AccountSearchResult` items."
  items: [AccountSearchResult]
}

union AccountSearchResult = Audio | Document | EmbeddedContent | File | Image | Video

type AccountUser implements Node & User {
  "`AccountUser` Id."
  id: ID!

  "`AccountUser` email."
  email: Email!

  "`AccountUser` name."
  name: String

  "`AccountUser` avatar."
  avatar: Url
}

type Brand implements Node {
  "`Brand` Id."
  id: ID!

  "`Brand` name."
  name: String!

  "**DEPRECATED** `Brand` color. This field will be removed. Use `rgbaColor` instead. | Date: 2023-01-01T00:00:00.000+00:00"
  color: String @deprecated(reason: "This field will be removed. Use `rgbaColor` instead. | Date: 2023-01-01T00:00:00.000+00:00")

  "`Brand` color."
  rgbaColor: RgbaColor

  "`Brand` avatar."
  avatar: Url

  "`Brand` slug."
  slug: String

  "**DEPRECATED** Retrieve all `Projects`. This field will be removed. Use `libraries` or `workspaceProjects` instead. | Date: 2023-01-01T00:00:00.000+00:00"
  projects(
    "`Project` types."
    types: [ProjectType]
  ): [Project] @deprecated(reason: "This field will be removed. Use `libraries` or `workspaceProjects` instead. | Date: 2023-01-01T00:00:00.000+00:00")

  "**BETA** Search for the assets on the brand level."
  search(
    "How many items to show in the search result field. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Query search options."
    query: BrandQueryInput
  ): BrandSearchItems

  "Retrieve all `Library` items."
  libraries(
    "How many items to show in the search result field. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "**BETA** Define search criteria for `Library` items in a `Brand`."
    query: LibraryQueryInput
  ): LibraryItems

  "Retrieve all `Workspace` items."
  workspaceProjects(
    "How many items to show in the search result field. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "**BETA** Define search criteria for `WorkspaceProject` items in a `Brand`."
    query: WorkspaceProjectQueryInput
  ): WorkspaceItems

  "**BETA** Paginated list of `Guideline` items for `Brand`."
  guidelines(
    "**BETA** Specifies the language in which the Guidelines should be delivered. This field must be set at the highest level in the GraphQL hierarchy. If the requested language is unavailable, the default language will be used as a fallback."
    language: LanguageCode

    "**BETA** How many `GuidelineItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): GuidelineItems

  "`Brand` `CustomMetadataProperty` items list."
  customMetadataProperties: [CustomMetadataProperty!]!

  "**BETA** Retrieve all `CreativeTemplate` items."
  creativeTemplates(
    "How many items to show in the search result field. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "**BETA** Define search criteria for `CreativeTemplate` items in a `Brand`."
    query: CreativeTemplateQueryInput
  ): CreativeTemplateItems!
}

"Different `Project` types"
enum ProjectType {
  DOCUMENT_LIBRARY
  ICON_LIBRARY
  LOGO_LIBRARY
  MEDIA_LIBRARY
  WORKSPACE
}

union Project = MediaLibrary | IconLibrary | LogoLibrary | DocumentLibrary | Workspace

type WorkspaceRootFolder {
  "**DEPRECATED** The `SubFolderItems` of the current `Library`\/`Workspace`. This field will be removed. Use `folders` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  subFolders(
    "How many `SubFolderItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `SubFolderItems` listing page number."
    page: Int = 1
  ): SubFolderItems! @deprecated(reason: "This field will be removed. Use `folders` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "The `FolderItems` of the current `Library`\/`Workspace`."
  folders(
    "How many `FolderItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `FolderItems` listing page number."
    page: Int = 1
  ): FolderItems!

  "`Library`\/`Workspace`'s `AssetItems` list."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current `AssetItems` listing page number."
    page: Int = 1

    "**BETA** Define search criteria for the `AssetItems` in the `Library`\/`Workspace`."
    query: FolderAssetQueryInput
  ): AssetItems!
}

type WorkspaceCollaborators {
  "`WorkspaceCollaboratorUserItems` list."
  users(
    "How many `WorkspaceCollaboratorUserItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): WorkspaceCollaboratorUserItems!
}

type WorkspaceCollaboratorUserItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of `User` items that have lowest required permissions to collaborate on a `Workspace`."
  items: [User]

  "**BETA** List of `WorkspaceProjectCollaboratorUserEdgeType` edges."
  edges: [WorkspaceProjectCollaboratorUserEdge!]!
}

type WorkspaceProjectCollaboratorUserEdge {
  "`User` that has the least required permissions to collaborate on a `WorkspaceProject`."
  node: User!

  "`User` role in the `WorkspaceProject`."
  role: String!
}

type WorkspaceUserPermissions {
  "Check if current `User` has `Asset` creation permissions in a specific `Workspace`."
  canCreateAssets: Boolean!

  "Check if current `User` has `Collaborator` view permissions in a specific `Workspace`."
  canViewCollaborators: Boolean!
}

input BrandQueryInput {
  "Search term used to retrieve matched results."
  term: String

  "Sort order of matched results."
  sortBy: BrandQuerySortByInput = RELEVANCE

  "**DEPRECATED** Specify the sources of the matched results. This field will be removed. Use `filter.sources` instead. | Date: 2023-07-01T00:00:00.000+00:00"
  searchIn: [BrandSearchQuerySource] = [EVERYWHERE]

  "Use filters to reduce the set of matched results."
  filter: BrandQueryFilterInput
}

"Search sorting option. Defines how the search results should be sorted."
enum BrandQuerySortByInput {
  "Sort the results by relevance."
  RELEVANCE

  "Sort the results by newest."
  NEWEST

  "Sort the results by oldest."
  OLDEST
}

"Search sources option. Defines the location of the search results."
enum BrandSearchQuerySource {
  "Search for the results in `Libraries`."
  LIBRARIES

  "Search for the results in the `WorkspaceProjects`."
  WORKSPACE_PROJECTS

  "Search for the results in the whole `Brand`."
  EVERYWHERE

  "Search for the results in the `LibraryPages`."
  LIBRARY_VIEWS
}

input BrandQueryFilterInput {
  "Filter set of the matched results by single tag or list of tags."
  hasTags: [String]

  "**BETA** Specify the sources to search in."
  sources: [BrandQuerySourceInput!]

  "**BETA** Filter set of the matched results by the externalId."
  externalId: ID
}

input BrandQuerySourceInput {
  "Specify the source type to search in."
  type: BrandQuerySourceTypeInput!

  "Specify the Ids of the source type you want to search in. If no Ids are specified, a search will be performed on all accessible Ids of the type."
  ids: [ID!]
}

"Search sources option. Defines the location of the search results."
enum BrandQuerySourceTypeInput {
  "Search for the results in `Libraries`."
  LIBRARIES

  "Search for the results in the `WorkspaceProjects`."
  WORKSPACE_PROJECTS

  "Search for the results in the `LibraryPages`."
  LIBRARY_PAGES
}

type BrandSearchItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of `BrandSearchResult` items."
  items: [BrandSearchResult]

  "List of `BrandSearchResult` edges."
  edges: [BrandSearchResultEdge]
}

union BrandSearchResult = Audio | Document | EmbeddedContent | File | Image | Video

type BrandSearchResultEdge {
  "`BrandSearchResult` title."
  title: String!

  "`BrandSearchResult` node."
  node: BrandSearchResult
}

input LibraryQueryInput {
  "**BETA** Sort order of the `Library` query result set."
  sortBy: LibraryQuerySort
}

"Query sorting option. Defines how the search results should be sorted."
enum LibraryQuerySort {
  "Sorts the results by the newest entry."
  NEWEST

  "Sorts the results by the oldest entry`."
  OLDEST
}

type LibraryItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `Library`"
  items: [Library]
}

input WorkspaceProjectQueryInput {
  "**BETA** Limit the result set based on `WorkspaceProject` state."
  state: WorkspaceProjectStateFilter = ALL

  "**BETA** Sort order of the `WorkspaceProject` query result set."
  sortBy: WorkspaceProjectQuerySort
}

"`WorkspaceProject` state filter."
enum WorkspaceProjectStateFilter {
  ALL
  ACTIVE
  ARCHIVED
}

"Query sorting option. Defines how the search results should be sorted."
enum WorkspaceProjectQuerySort {
  "Sorts the results by the newest entry."
  NEWEST

  "Sorts the results by the oldest entry`."
  OLDEST

  "Sorts the results by the newest activity entry."
  NEWEST_ACTIVITY

  "Sorts the results by the oldest activity entry."
  OLDEST_ACTIVITY
}

type WorkspaceItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `Workspace`."
  items: [Workspace]
}

"Language code based on the ISO 639-1 standard, represented as two-letter codes such as en (English), de (German), and es (Spanish)."
enum LanguageCode {
  "Abkhazian"
  AB

  "Afar"
  AA

  "Afrikaans"
  AF

  "Akan"
  AK

  "Albanian"
  SQ

  "Amharic"
  AM

  "Arabic"
  AR

  "Aragonese"
  AN

  "Armenian"
  HY

  "Assamese"
  AS

  "Avaric"
  AV

  "Avestan"
  AE

  "Aymara"
  AY

  "Azerbaijani"
  AZ

  "Bambara"
  BM

  "Bashkir"
  BA

  "Basque"
  EU

  "Belarusian"
  BE

  "Bengali"
  BN

  "Bihari languages"
  BH

  "Bislama"
  BI

  "Bosnian"
  BS

  "Breton"
  BR

  "Bulgarian"
  BG

  "Burmese"
  MY

  "Catalan, Valencian"
  CA

  "Central Khmer"
  KM

  "Chamorro"
  CH

  "Chechen"
  CE

  "Chichewa, Chewa, Nyanja"
  NY

  "Chinese"
  ZH

  "Church Slavonic, Old Bulgarian, Old Church Slavonic"
  CU

  "Chuvash"
  CV

  "Cornish"
  KW

  "Corsican"
  CO

  "Cree"
  CR

  "Croatian"
  HR

  "Czech"
  CS

  "Danish"
  DA

  "Divehi, Dhivehi, Maldivian"
  DV

  "Dutch, Flemish"
  NL

  "Dzongkha"
  DZ

  "English"
  EN

  "Esperanto"
  EO

  "Estonian"
  ET

  "Ewe"
  EE

  "Faroese"
  FO

  "Fijian"
  FJ

  "Finnish"
  FI

  "French"
  FR

  "Fulah"
  FF

  "Gaelic, Scottish Gaelic"
  GD

  "Galician"
  GL

  "Ganda"
  LG

  "Georgian"
  KA

  "German"
  DE

  "Gikuyu, Kikuyu"
  KI

  "Greek (Modern)"
  EL

  "Greenlandic, Kalaallisut"
  KL

  "Guarani"
  GN

  "Gujarati"
  GU

  "Haitian, Haitian Creole"
  HT

  "Hausa"
  HA

  "Hebrew"
  HE

  "Herero"
  HZ

  "Hindi"
  HI

  "Hiri Motu"
  HO

  "Hungarian"
  HU

  "Icelandic"
  IS

  "Ido"
  IO

  "Igbo"
  IG

  "Indonesian"
  ID

  "Interlingua (International Auxiliary Language Association)"
  IA

  "Interlingue"
  IE

  "Inuktitut"
  IU

  "Inupiaq"
  IK

  "Irish"
  GA

  "Italian"
  IT

  "Japanese"
  JA

  "Javanese"
  JV

  "Kannada"
  KN

  "Kanuri"
  KR

  "Kashmiri"
  KS

  "Kazakh"
  KK

  "Kinyarwanda"
  RW

  "Komi"
  KV

  "Kongo"
  KG

  "Korean"
  KO

  "Kwanyama, Kuanyama"
  KJ

  "Kurdish"
  KU

  "Kyrgyz"
  KY

  "Lao"
  LO

  "Latin"
  LA

  "Latvian"
  LV

  "Letzeburgesch, Luxembourgish"
  LB

  "Limburgish, Limburgan, Limburger"
  LI

  "Lingala"
  LN

  "Lithuanian"
  LT

  "Luba-Katanga"
  LU

  "Macedonian"
  MK

  "Malagasy"
  MG

  "Malay"
  MS

  "Malayalam"
  ML

  "Maltese"
  MT

  "Manx"
  GV

  "Maori"
  MI

  "Marathi"
  MR

  "Marshallese"
  MH

  "Moldovan, Moldavian, Romanian"
  RO

  "Mongolian"
  MN

  "Nauru"
  NA

  "Navajo, Navaho"
  NV

  "Northern Ndebele"
  ND

  "Ndonga"
  NG

  "Nepali"
  NE

  "Northern Sami"
  SE

  "Norwegian"
  NO

  "Norwegian Bokmål"
  NB

  "Norwegian Nynorsk"
  NN

  "Nuosu, Sichuan Yi"
  II

  "Occitan (post 1500)"
  OC

  "Ojibwa"
  OJ

  "Oriya"
  OR

  "Oromo"
  OM

  "Ossetian, Ossetic"
  OS

  "Pali"
  PI

  "Panjabi, Punjabi"
  PA

  "Pashto, Pushto"
  PS

  "Persian"
  FA

  "Polish"
  PL

  "Portuguese"
  PT

  "Quechua"
  QU

  "Romansh"
  RM

  "Rundi"
  RN

  "Russian"
  RU

  "Samoan"
  SM

  "Sango"
  SG

  "Sanskrit"
  SA

  "Sardinian"
  SC

  "Serbian"
  SR

  "Shona"
  SN

  "Sindhi"
  SD

  "Sinhala, Sinhalese"
  SI

  "Slovak"
  SK

  "Slovenian"
  SL

  "Somali"
  SO

  "Sotho, Southern"
  ST

  "South Ndebele"
  NR

  "Spanish, Castilian"
  ES

  "Sundanese"
  SU

  "Swahili"
  SW

  "Swati"
  SS

  "Swedish"
  SV

  "Tagalog"
  TL

  "Tahitian"
  TY

  "Tajik"
  TG

  "Tamil"
  TA

  "Tatar"
  TT

  "Telugu"
  TE

  "Thai"
  TH

  "Tibetan"
  BO

  "Tigrinya"
  TI

  "Tonga (Tonga Islands)"
  TO

  "Tsonga"
  TS

  "Tswana"
  TN

  "Turkish"
  TR

  "Turkmen"
  TK

  "Twi"
  TW

  "Uighur, Uyghur"
  UG

  "Ukrainian"
  UK

  "Urdu"
  UR

  "Uzbek"
  UZ

  "Venda"
  VE

  "Vietnamese"
  VI

  "Volap_k"
  VO

  "Walloon"
  WA

  "Welsh"
  CY

  "Western Frisian"
  FY

  "Wolof"
  WO

  "Xhosa"
  XH

  "Yiddish"
  YI

  "Yoruba"
  YO

  "Zhuang, Chuang"
  ZA

  "Zulu"
  ZU
}

type GuidelineItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of `Guideline` type projects."
  items: [Guideline]
}

type Language {
  "**BETA** The ISO code of the language."
  code: LanguageCode!

  "**BETA** The name of the language in English."
  name: String!
}

type LibraryPageItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `LibraryPage`."
  items: [LibraryPage]
}

"List of possible `Library` types."
enum LibraryType {
  ICON_LIBRARY
  MEDIA_LIBRARY
  LOGO_LIBRARY
  DOCUMENT_LIBRARY
}

type LibraryPageCollectionItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of `LibraryPage` `Collection` items."
  items: [LibraryPageCollection]!
}

type LibraryPageCollection implements Node {
  "`Collection` Id."
  id: ID!

  "`Collection` name."
  name: String!

  "`LibraryPageCollection`'s `Asset` items list."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "`LibraryPageCollection`'s privacy state setting."
  isPrivate: Boolean!
}

input LibraryPageAssetQueryInput {
  "Search term used to retrieve matched results."
  term: String
}

type LibraryPageAssetItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `Asset`."
  items: [Asset]
}

type GuidelinePageItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "**BETA** List of `GuidelinePage` items."
  items: [GuidelinePage]
}

type GuidelinePage {
  "**BETA** The `GuidelinePage` id."
  id: ID!

  "**BETA** The title of the `GuidelinePage`"
  title: String!

  "**BETA** The url of the `GuidelinePage`"
  url: Url!

  "**BETA** A list of `GuidelinePageSection`s that belong to this `GuidelinePage`"
  sections(
    "**BETA** How many `GuidelinePageSection` to show per query."
    limit: Int = 25

    "**BETA** Current page number."
    page: Int = 1
  ): GuidelinePageSectionItems
}

type GuidelinePageSectionItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "**BETA** List of `GuidelinePageSection` items."
  items: [GuidelinePageSection]
}

type GuidelinePageSection {
  "**BETA** `GuidelinePageSection` id."
  id: ID!

  "**BETA** `GuidelinePageSectionElement` that are located within this `GuidelinePageSection`."
  elements(
    "**BETA** Current page number."
    page: Int = 1

    "How many `GuidelinePageSectionElement` to show per query."
    limit: Int = 25
  ): GuidelinePageSectionElementItems
}

type GuidelinePageSectionElementItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "**BETA** `GuidelinePageSectionElementUnion` items list."
  items: [GuidelinePageSectionElement]
}

union GuidelinePageSectionElement = GuidelinePageHeading | GuidelinePageBlock | GuidelinePageBlockReference

type GuidelinePageHeading {
  "**BETA** `GuidelinePageHeading` id."
  id: ID!

  "**BETA** `GuidelinePageHeading` title."
  title: String!

  "**BETA** The timestamp of the most recent modification to the `GuidelinePageHeading`. If not modified, this represents the creation time."
  lastModified: DateTime!
}

type GuidelinePageBlock {
  "**BETA** The id of the `GuidelinePageBlock`."
  id: ID!

  "**BETA** The searchable content of the `GuidelinePageBlock`. When the block cannot be serialized, this field is `null`."
  content: String

  "**BETA** The url of the `GuidelinePageBlock`"
  url: Url!

  "**BETA** The timestamp of the most recent modification to the `GuidelinePageBlock`. If not modified, this represents the creation time."
  lastModified: DateTime!
}

type GuidelinePageBlockReference {
  "**BETA** The id of the `GuidelinePageBlockReference`."
  id: ID!

  "**BETA** The `GuidelinePageBlock` that this reference resolves to."
  block: GuidelinePageBlock!
}

input CreativeTemplateQueryInput {
  "**BETA** Sort order of the `CreativeTemplate` query result set."
  sortBy: CreativeTemplateQuerySort
}

"Query sorting option. Defines how the search results should be sorted."
enum CreativeTemplateQuerySort {
  "Sorts the results by the newest entry."
  NEWEST

  "Sorts the results by the oldest entry`."
  OLDEST
}

type CreativeTemplateItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "**BETA** List of type `CreativeTemplate`"
  items: [CreativeTemplate]!
}

type CreativeTemplate {
  "**BETA** `CreativeTemplate` id."
  id: ID!

  "**BETA** Id of the `Brand` of the `CreativeTemplate`."
  brandId: ID!

  "**BETA** Name of the `CreativeTemplate`."
  name: String!

  "**BETA** Description of the `CreativeTemplate`."
  description: String

  "**BETA** Retrieve list of all `CreativeTemplatePage` items belonging to `CreativeTemplate`."
  pages: [CreativeTemplatePage!]!

  "**BETA** Retrieve a `CreativeTemplateVariable` item by `CreativeTemplateVariable` key."
  variable(
    "**BETA** `CreativeTemplateVariable` key."
    key: String!
  ): CreativeTemplateVariable

  "**BETA** Retrieve list of all `CreativeTemplateVariable` items belonging to `CreativeTemplate`."
  variables: [CreativeTemplateVariable!]!

  "**BETA** Retrieve Asset ID."
  assetId: ID

  "**BETA** Tags of the `CreativeTemplate`."
  tags: [Tag]!
}

type CreativeTemplatePage {
  "**BETA** Preview URL of `CreativeTemplatePage`."
  previewUrl: Url!

  "**BETA** Width of the `CreativeTemplatePage`."
  width: Int!

  "**BETA** Height of the `CreativeTemplatePage`."
  height: Int!

  "**BETA** `CreativeTemplatePage` unique identifier."
  pageIndex: Int!

  "**BETA** Name of the `CreativeTemplatePage`."
  name: String
}

type CreativeTemplateVariable {
  "**BETA** Key of the `CreativeTemplateVariable`."
  key: String!

  "**BETA** Name of the `CreativeTemplateVariable`."
  name: String!

  "**BETA** Description of the `CreativeTemplateVariable`."
  description: String

  "**BETA** Type of the `CreativeTemplateVariable`."
  type: CreativeTemplateVariableType!

  "**BETA** Value of the `CreativeTemplateVariable`. See `CreativeTemplateVariableType` for valid formats."
  value: Any

  "**BETA** Number of template items connected to the `CreativeTemplateVariable`."
  connectionCount: Int!
}

"List of possible `CreativeTemplateVariable` types."
enum CreativeTemplateVariableType {
  "Boolean Variable Type, possible values are `true` or `false`"
  BOOL

  "Number Variable Type"
  NUMBER

  "Text content Variable Type"
  TEXT

  "Image Variable Type, values are `AssetID`s for referencing"
  IMAGE

  "Color Variable Type, you can either pass an rgba object or a HEX value as string"
  COLOR
}

type CustomMetadataProperty implements Node {
  "`CustomMetadataProperty` Id."
  id: ID!

  "`User` who created the `CustomMetadataProperty`."
  creator: User!

  "`DateTime` of the `CustomMetadataProperty` creation."
  createdAt: DateTime!

  "`User` who last modified the `CustomMetadataProperty`."
  modifier: User

  "`DateTime` of the `CustomMetadataProperty`'s last modification."
  modifiedAt: DateTime

  "`CustomMetadataProperty` name."
  name: String!

  "`CustomMetadataProperty` type details."
  type: CustomMetadataPropertyType!

  "`CustomMetadataProperty` help text."
  helpText: String

  "Indicates if a `CustomMetadataProperty` is required to be defined."
  isRequired: Boolean!

  "`CustomMetadataProperty` value set to newly update `Assets` by default."
  defaultValue: Any
}

type Guideline implements Node {
  "`Guideline` Id."
  id: ID!

  "`Guideline` name."
  name: String

  "`Guideline` color."
  color: RgbaColor

  "`Guideline` internal url."
  url: Url!

  "**BETA** The default language of the `Guideline`, or `null` if not set."
  defaultLanguage: Language

  "**BETA** Languages in which the `Guideline` is available."
  translationLanguages: [Language]!

  "Paginated list of `LibraryPage` items for `Guideline`."
  libraryPages(
    "How many `LibraryPageItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): LibraryPageItems!

  "**BETA** A list of `GuidelinePage`s that belong to this `Guideline`"
  pages(
    "**BETA** How many `GuidelinePage` to show per query."
    limit: Int = 25

    "**BETA** Current page number."
    page: Int = 1
  ): GuidelinePageItems
}

type Collection implements Node {
  "`Collection` Id."
  id: ID!

  "`Collection` name."
  name: String!

  "`Collection`'s `Asset` items list."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): AssetItems!

  "**DEPRECATED** `Collection`'s privacy state setting. This field will be removed. | Date: 2024-01-01T00:00:00.000+00:00"
  isPrivate: Boolean @deprecated(reason: "This field will be removed. | Date: 2024-01-01T00:00:00.000+00:00")

  "`Collection`'s permissions of the current `User`."
  currentUserPermissions: CollectionUserPermissions!
}

type LibraryPage implements Node {
  "`LibraryPage` Id."
  id: ID!

  "`LibraryPage` title."
  title: String!

  "`LibraryPage` type."
  type: LibraryType!

  "**BETA** `LibraryPage` `Collection` items list."
  collections(
    "How many `LibraryPageCollectionItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): LibraryPageCollectionItems!

  "`LibraryPage` `Asset` items list."
  assets(
    "How many `LibraryPageAssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Define search criteria for `Assets` in this `LibraryPage`."
    query: LibraryPageAssetQueryInput
  ): LibraryPageAssetItems!
}

type ProjectWebhook implements Node & Webhook {
  "`Webhook` Id."
  id: ID!

  "The `creator` is the `User` who created the `Webhook`."
  creator: User!

  "DateTime of the `Webhook` creation."
  createdAt: DateTime!

  "`Webhook` name."
  name: String!

  "The randomly generated secret of the current `Webhook`."
  secret: String!

  "The `Url` which will be called by the `Webhook`"
  notificationUrl: Url!

  "Returns the associated `Project`."
  project: Project!
}

"`WebhookInterface` for `Webhook` returnable types."
interface Webhook {
  "`Workspace` Id."
  id: ID!

  "The `creator` is the `User` who created the asset on Frontify."
  creator: User!

  "`DateTime` of the `Asset` creation."
  createdAt: DateTime!

  "The name of the current `Webhook`."
  name: String!

  "The `Url` which will be called by the `Webhook`."
  notificationUrl: Url!

  "The randomly generated secret of the current `Webhook`."
  secret: String!
}

type UserGroup implements Node {
  "`UserGroup` Id."
  id: ID!

  "`UserGroup` name."
  name: String

  "`UserGroup`'s `UserItems`."
  users(
    "How many `UserItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): UserItems
}

type Workspace implements Node {
  "`Library`\/`Workspace` Id."
  id: ID!

  "`Library`\/`Workspace` name."
  name: String!

  "`Library`\/`Workspace` color."
  color: RgbaColor

  "**DEPRECATED** Amount of `Assets` contained in the `Library`\/`Workspace`. This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00"
  assetCount: Int @deprecated(reason: "This field will be removed. Use `assets`.`total` instead. | Date: 2024-07-01T00:00:00.000+00:00")

  "Search or list `Assets` in the `Library`\/`Workspace`."
  assets(
    "How many `AssetItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1

    "Define search criteria for `Assets` in the `Library`\/`Workspace`."
    query: AssetQueryInput
  ): AssetItems!

  "`Library`\/`Workspace` `License` items list."
  licenses: [License]

  "**DEPRECATED** `Library`\/`Workspace` `MetadataField` items list. This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  metadataFields: [MetadataField] @deprecated(reason: "This field will be removed. Use `customMetadataProperties` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**BETA** The `Workflow` belonging to the given `Library`\/`Workspace`."
  workflow: Workflow!

  "Browse the `Workspace`'s `SubFolderItems` and `AssetItems`."
  browse: WorkspaceRootFolder!

  "`Workspace` collaborators."
  collaborators: WorkspaceCollaborators

  "`Workspace` permissions of the current `User`."
  currentUserPermissions: WorkspaceUserPermissions!

  "**BETA** `Workspace` state."
  isArchived: Boolean!

  "List of `CustomMetadataProperty` items and values associated to `Workspace`."
  customMetadata: [CustomMetadata!]!
}

type RootQuery {
  "Get the current `User`."
  currentUser: User!

  "Retrieve current `Account` details."
  account: Account!

  "**DEPRECATED** Retrieve `Project` details by Id. This field will be removed. Use `library` or `workspaceProject` instead. | Date: 2023-01-01T00:00:00.000+00:00"
  project(
    "`Project` Id."
    id: ID!
  ): Project @deprecated(reason: "This field will be removed. Use `library` or `workspaceProject` instead. | Date: 2023-01-01T00:00:00.000+00:00")

  "Retrieve `Library` details by Id."
  library(
    "`Library` Id."
    id: ID!
  ): Library

  "Retrieve `WorkspaceProject` details by Id."
  workspaceProject(
    "`Workspace` Id."
    id: ID!
  ): Workspace

  "Retrieve `WebhookItems` related to current `Account`."
  webhooks(
    "How many `WebhookItems` to show per query. Min: 1, Max: 100."
    limit: Int = 25

    "Current page number."
    page: Int = 1
  ): WebhookItems

  "Retrieve `Assets` details by Ids."
  assets(
    "`Asset` Ids."
    ids: [ID!]!
  ): [Asset]

  "Retrieve `Asset` details by Id."
  asset(
    "`Asset` Id."
    id: ID!
  ): Asset

  "Retrieve a unique client tracking id in the format: `<ACCOUNT_ID>-<USER_ID>`."
  clientTrackingId: ID

  "**BETA** Retrieve a `CreativeTemplate` item by Id."
  creativeTemplate(
    "**BETA** `CreativeTemplate` Id."
    id: ID!
  ): CreativeTemplate

  "**BETA** Retrieve a `CreativeExport` item by `CreativeJob` Id."
  creativeExport(
    "**BETA** `CreativeJob` Id."
    id: ID!
  ): CreativeExport

  "Retrieve a `Brand` by its Id."
  brand(
    "`Brand` Id."
    id: ID!
  ): Brand

  "Retrieve `Brand` list for current `Account`."
  brands: [Brand]

  "**BETA** Retrieve a `GuidelinePage` by its id."
  guidelinePage(
    "**BETA** The id of the `GuidelinePage` to retrieve."
    id: ID!

    "**BETA** Specifies the language in which the GuidelinePage should be delivered. If the requested language is unavailable, the default language will be used as a fallback."
    language: LanguageCode
  ): GuidelinePage

  "Retrieve `Node` details by Id."
  node(
    "`Node` Id."
    id: ID!
  ): Node
}

type WebhookItems {
  "Total amount of results."
  total: Int!

  "Current page number."
  page: Int!

  "Number of results per page."
  limit: Int!

  "Indicates if a next page is available or not"
  hasNextPage: Boolean!

  "List of type `Webhook`."
  items: [Webhook]
}

type CreativeExport {
  "**BETA** `CreativeJob` Id."
  id: ID!

  "**BETA** `CreativeJob` status."
  status: CreativeJobStatus!

  "**BETA** Generated Creative."
  result: CreativeResult
}

"List of possible `Creative Job` statuses."
enum CreativeJobStatus {
  "The job is currently being prepared and is awaiting rendering."
  PROCESSING

  "The job is currently rendering."
  RENDERING

  "The job has been canceled successfully."
  CANCELED

  "The job has been completed successfully."
  FINISHED

  "The processing of the job failed."
  FAILED
}

type CreativeResult {
  "**BETA** Signed `Url` to download the Creative."
  downloadUrl: Url!

  "**BETA** List of signed `Url`s to download each page of the Creative."
  pageDownloadUrls: [Url!]!

  "**BETA** `Asset` details of the stored asset when save-to has been used."
  asset: File
}

type RootMutation {
  "Add a relation between an existing `Asset` and `License`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  addAssetLicense(
    "`AddAssetLicense` input argument."
    input: AddAssetLicenseInput!
  ): AddAssetLicense

  "**DEPRECATED** Add a new relation between an existing `Asset` and an existing `MetadataField` with its value. The value will be automatically created and linked to its `MetadataField`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`. This field will be removed. Use `addCustomMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  addAssetMetadataFieldValue(
    "`AddAssetMetadataFieldValue` input argument."
    input: AddAssetMetadataFieldValueInput!
  ): AddAssetMetadataFieldValue @deprecated(reason: "This field will be removed. Use `addCustomMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "Add new `Asset` preview image. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  addAssetPreviewImage(
    "`AddAssetPreviewImage` input argument."
    input: AddAssetPreviewImageInput!
  ): AddAssetPreviewImage

  "Relate existing `Asset`s. The `relatedAssetIds` input field list is limited to 100 ids per request and cannot contain the same `assetId` input field value. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  addAssetRelations(
    "`AddAssetRelations` input argument."
    input: AddAssetRelationsInput!
  ): AddAssetRelations

  "Add new `Asset` tags. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  addAssetTags(
    "`AddAssetTags` input argument."
    input: AddAssetTagsInput!
  ): AddAssetTags

  "Add `Assets` to the existing `Collection`. Requires `basic:write` scope to be accessible and `Collection` permission level `EDIT`."
  addCollectionAssets(
    "`AddCollectionAssets` input argument."
    input: AddCollectionAssetsInput!
  ): AddCollectionAssets

  "Add `CustomMetadata` values to a supported parent (`Asset` | `WorkspaceProject`). Requires `basic:write` scope to be accessible and permission level `EDIT` for the respective parent."
  addCustomMetadata(
    "`AddCustomMetadata` input argument."
    input: AddCustomMetadataInput!
  ): AddCustomMetadata

  "Add options to an existing `SELECT` or `MULTISELECT` type `CustomMetadataProperty`. RequiresRequires `basic:write` scope to be accessible and `CustomMetadataProperty` permission level `EDIT`."
  addCustomMetadataPropertyOptions(
    "`AddCustomMetadataPropertyOptions` input argument."
    input: AddCustomMetadataPropertyOptionsInput!
  ): AddCustomMetadataPropertyOptions

  "**BETA** Add a new `WorkflowChecklistItem` for a given `WorkflowTask`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  addWorkflowChecklistItem(
    "**BETA** `AddWorkflowChecklistItem` input argument."
    input: AddWorkflowChecklistItemInput!
  ): AddWorkflowChecklistItem

  "**BETA** Add a new `WorkflowChecklistPreset` for a given `WorkflowStatus`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  addWorkflowChecklistPreset(
    "**BETA** `AddWorkflowChecklistPreset` input argument."
    input: AddWorkflowChecklistPresetInput!
  ): AddWorkflowChecklistPreset

  "**BETA** Add assignees to an existing `WorkflowStatus`. Currently, only one assignee is supported. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  addWorkflowStatusAssignees(
    "**BETA** `AddWorkflowStatusAssignees` input argument."
    input: AddWorkflowStatusAssigneesInput!
  ): AddWorkflowStatusAssignees

  "**BETA** Add assignees to an existing `WorkflowTask`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  addWorkflowTaskAssignees(
    "**BETA** `AddWorkflowTaskAssignees` input argument."
    input: AddWorkflowTaskAssigneesInput!
  ): AddWorkflowTaskAssignees

  "**BETA** Create `AccountUser`."
  createAccountUser(
    "**BETA** `CreateAccountUser` input argument."
    input: CreateAccountUserInput!
  ): CreateAccountUser

  "Create a new `Asset`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  createAsset(
    "`CreateAsset` input argument."
    input: CreateAssetInput!
  ): CreateAsset

  "Create a new `Asset` `Comment`. Requires `basic:write` scope to be accessible and `Asset` permission level `COMMENT`."
  createAssetComment(
    "`CreateAssetComment` input argument."
    input: CreateAssetCommentInput!
  ): CreateAssetComment

  "**BETA** Create a new permission token for multiple `Assets` or for a single `Collection` or `Folder`."
  createPermissionToken(
    "**BETA** `CreatePermissionToken` input argument."
    input: CreatePermissionTokenInput!
  ): CreatePermissionToken

  "**BETA** Create new `AssetSubmission` item(s). Requires a valid `AssetSubmissionRequest` `token` input."
  createAssetSubmissions(
    "**BETA** `CreateAssetSubmissions` input argument."
    input: CreateAssetSubmissionsInput!
  ): CreateAssetSubmissions

  "**BETA** Create a new `AssetVariant`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  createAssetVariant(
    "**BETA** `CreateAssetVariant` input argument."
    input: CreateAssetVariantInput!
  ): CreateAssetVariant

  "Create a new `Attachment`. Attachments require a valid parent ID string. This mutation currently only supports attachments for parents of `Asset` type. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  createAttachment(
    "`CreateAttachment` input argument."
    input: CreateAttachmentInput!
  ): CreateAttachment

  "Create a new `Collection`. Currently supported for `Library` type parent entities only. Requires `basic:write` scope to be accessible and `Collection` permission level `EDIT`."
  createCollection(
    "`CreateCollection` input argument."
    input: CreateCollectionInput!
  ): CreateCollection

  "Create a new `CustomMetadataProperty`. RequiresRequires `basic:write` scope to be accessible and `Brand` or `Project` permission level `EDIT`."
  createCustomMetadataProperty(
    "`CreateCustomMetadataProperty` input argument."
    input: CreateCustomMetadataPropertyInput!
  ): CreateCustomMetadataProperty

  "Create a new External `Asset` from a url. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  createExternalAsset(
    "`CreateExternalAsset` input argument."
    input: CreateExternalAssetInput!
  ): CreateExternalAsset

  "Create a new `Folder`. Requires `basic:write` scope to be accessible and `Project` or `Folder` permission level `EDIT`."
  createFolder(
    "`CreateFolder` input argument."
    input: CreateFolderInput!
  ): CreateFolder

  "Create a new `Project` `License`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  createLicense(
    "`CreateLicense` input argument."
    input: CreateLicenseInput!
  ): CreateLicense

  "**DEPRECATED** Create a new `Project` `MetadataField` with your desired configuration. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`. This field will be removed. Use `createCustomMetadataProperty` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  createMetadataField(
    "`CreateMetadataField` input argument."
    input: CreateMetadataFieldInput!
  ): CreateMetadataField @deprecated(reason: "This field will be removed. Use `createCustomMetadataProperty` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**BETA** Create a new `ShareLink` Requires `basic:write` scope to be accessible and a valid permission token."
  createShareLink(
    "**BETA** `CreateShareLink` input argument."
    input: CreateShareLinkInput!
  ): CreateShareLink

  "**BETA** Create new `WorkflowStatus` in a given `Workflow`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  createWorkflowStatus(
    "**BETA** `CreateWorkflowStatus` input argument."
    input: CreateWorkflowStatusInput!
  ): CreateWorkflowStatus

  "**BETA** Create a new `WorkflowTask` for an `Asset` in a given `WorkflowStatus`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  createAssetWorkflowTask(
    "**BETA** `CreateAssetWorkflowTask` input argument."
    input: CreateAssetWorkflowTaskInput!
  ): CreateAssetWorkflowTask

  "Create a new `Workspace` type `Project`. Requires `basic:write` scope to be accessible."
  createWorkspaceProject(
    "`CreateWorkspaceProject` input argument."
    input: CreateWorkspaceProjectInput!
  ): CreateWorkspaceProject

  "**BETA** Delete an existing `AccountUser`. Requires `basic:write` scope to be accessible and `Account` permission level `ADMIN`."
  deleteAccountUser(
    "**BETA** `DeleteAccountUser` input argument."
    input: DeleteAccountUserInput!
  ): DeleteAccountUser

  "Delete an existing `Asset`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  deleteAsset(
    "`DeleteAsset` input argument."
    input: DeleteAssetInput!
  ): DeleteAsset

  "Delete an existing `Attachment`. Requires `basic:write` scope to be accessible and depending on the `Attachment` type, either `Portal` or `Asset` permission level `EDIT`."
  deleteAttachment(
    "`DeleteAttachment` input argument."
    input: DeleteAttachmentInput!
  ): DeleteAttachment

  "**BETA** Delete an existing `AssetVariant`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  deleteAssetVariant(
    "**BETA** `DeleteAssetVariant` input argument."
    input: DeleteAssetVariantInput!
  ): DeleteAssetVariant

  "Delete an existing `Collection`. Requires `basic:write` scope to be accessible and `Collection` permission level `EDIT`."
  deleteCollection(
    "`DeleteCollection` input argument."
    input: DeleteCollectionInput!
  ): DeleteCollection

  "Delete an existing `Comment`. This will update and\/or remove all relations to that `Comment`. Requires `basic:write` scope to be accessible and `Asset` permission level `COMMENT`."
  deleteComment(
    "`DeleteComment` input argument."
    input: DeleteCommentInput!
  ): DeleteComment

  "Delete an existing `CustomMetadataProperty`."
  deleteCustomMetadataProperty(
    "`DeleteCustomMetadataProperty` input argument."
    input: DeleteCustomMetadataPropertyInput!
  ): DeleteCustomMetadataProperty

  "Delete the existing `Folders`. This will delete all of the `Assets` and `SubFolders` within the `Folders`. Requires `basic:write` scope to be accessible and `Folder` permission level `EDIT`."
  deleteFolders(
    "`DeleteFolders` input argument."
    input: DeleteFoldersInput!
  ): DeleteFolders

  "Delete an existing `Project` `License`. This will remove all relations to that `License`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  deleteLicense(
    "`DeleteLicense` input argument."
    input: DeleteLicenseInput!
  ): DeleteLicense

  "**DEPRECATED** Delete an existing `Project` `MetadataField`. Existing `MetadataField`'s with the same value with be automatically removed. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`. This field will be removed. Use `deleteCustomMetadataProperty` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  deleteMetadataField(
    "`DeleteMetadataField` input argument."
    input: DeleteMetadataFieldInput!
  ): DeleteMetadataField @deprecated(reason: "This field will be removed. Use `deleteCustomMetadataProperty` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**BETA** Delete an existing `WorkflowStatus`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  deleteWorkflowStatus(
    "**BETA** `DeleteWorkflowStatus` input argument."
    input: DeleteWorkflowStatusInput!
  ): DeleteWorkflowStatus

  "**BETA** Delete an existing `WorkflowTask`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  deleteWorkflowTask(
    "**BETA** `DeleteWorkflowTask` input argument."
    input: DeleteWorkflowTaskInput!
  ): DeleteWorkflowTask

  "Edit an existing `AssetComment`. Requires `basic:write` scope to be accessible and `Asset` permission level `COMMENT`."
  editComment(
    "`EditComment` input argument."
    input: EditCommentInput!
  ): EditComment

  "Install `Webhook`. Requires `basic:write` and `webhook:write` scopes to be accessible and `Project` permission level `EDIT`."
  installProjectWebhook(
    "`InstallProjectWebhook` input argument."
    input: InstallProjectWebhookInput!
  ): InstallProjectWebhook

  "Invite `Project` user. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`. Limitations: Does not work if User Provisioning feature is enabled."
  inviteProjectUser(
    "`InviteProjectUser` input argument."
    input: InviteProjectUserInput!
  ): InviteProjectUser

  "Move existing `Asset` item(s) to the given `Library`, `Workspace` or `Folder` destination. Only moves within the same `Library`\/`Workspace` are supported by this operation. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  moveAssets(
    "`MoveAssets` input argument."
    input: MoveAssetsInput!
  ): MoveAssets

  "Move existing `Folder` item(s) to the given `Library`, `Workspace` or `Folder` destination. This operation will move all of the `Asset` item(s) and `SubFolder` item(s) within the provided `Folder` item(s). Only moves within the same `Library`\/`Workspace` are supported by this operation. Requires `basic:write` scope to be accessible and `Folder` permission level `EDIT`."
  moveFolders(
    "`MoveFolders` input argument."
    input: MoveFoldersInput!
  ): MoveFolders

  "**BETA** Move one or more `WorkflowTask` to a new `WorkflowStatus`. All `EnterRule` of the destination `WorkflowStatus` have to be satisfied to be able to move. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  moveWorkflowTask(
    "**BETA** `MoveWorkflowTask` input argument."
    input: MoveWorkflowTaskInput!
  ): MoveWorkflowTask

  "Remove an existing relation between an `Asset` and a `License`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  removeAssetLicense(
    "`RemoveAssetLicense` input argument."
    input: RemoveAssetLicenseInput!
  ): RemoveAssetLicense

  "Remove existing `Asset` preview image. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  removeAssetPreviewImage(
    "`RemoveAssetPreviewImage` input argument."
    input: RemoveAssetPreviewImageInput!
  ): RemoveAssetPreviewImage

  "**BETA** Remove existing relations between `Asset` items. The `relatedAssetIds` input field list is limited to 100 ids per request and cannot contain the same `assetId` input field value. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  removeAssetRelations(
    "**BETA** `RemoveAssetRelations` input argument."
    input: RemoveAssetRelationsInput!
  ): RemoveAssetRelations

  "Remove existing `Asset` tags. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  removeAssetTags(
    "`RemoveAssetTags` input argument."
    input: RemoveAssetTagsInput!
  ): RemoveAssetTags

  "Remove `Assets` from the existing `Collection`. Requires `basic:write` scope to be accessible and `Collection` permission level `EDIT`."
  removeCollectionAssets(
    "`RemoveCollectionAssets` input argument."
    input: RemoveCollectionAssetsInput!
  ): RemoveCollectionAssets

  "Remove `CustomMetadata` values from a supported parent (`Asset` | `WorkspaceProject`). Requires `basic:write` scope to be accessible and permission level `EDIT` for the respective parent."
  removeCustomMetadata(
    "`RemoveCustomMetadata` input argument."
    input: RemoveCustomMetadataInput!
  ): RemoveCustomMetadata

  "Remove options from an existing `SELECT` or `MULTISELECT` type `CustomMetadataProperty`. RequiresRequires `basic:write` scope to be accessible and `CustomMetadataProperty` permission level `EDIT`."
  removeCustomMetadataPropertyOptions(
    "`RemoveCustomMetadataPropertyOptions` input argument."
    input: RemoveCustomMetadataPropertyOptionsInput!
  ): RemoveCustomMetadataPropertyOptions

  "**DEPRECATED** Remove existing `MetadataField` value.Existing relations to that `MetadataField` with the same value will be automatically removed.Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`. This field will be removed. Use `removeCustomMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00"
  removeMetadataValue(
    "`RemoveMetadataValue` input argument."
    input: RemoveMetadataValueInput!
  ): RemoveMetadataValue @deprecated(reason: "This field will be removed. Use `removeCustomMetadata` instead. | Date: 2025-07-01T00:00:00.000+00:00")

  "**BETA** Remove a `WorkflowChecklistItem`.Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  removeWorkflowChecklistItem(
    "**BETA** `RemoveWorkflowChecklistItem` input argument."
    input: RemoveWorkflowChecklistItemInput!
  ): RemoveWorkflowChecklistItem

  "**BETA** Remove a `WorkflowChecklistPreset`.Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  removeWorkflowChecklistPreset(
    "**BETA** `RemoveWorkflowChecklistPreset` input argument."
    input: RemoveWorkflowChecklistPresetInput!
  ): RemoveWorkflowChecklistPreset

  "**BETA** Remove assignees from an existing `WorkflowStatus`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  removeWorkflowStatusAssignees(
    "**BETA** `RemoveWorkflowStatusAssignees` input argument."
    input: RemoveWorkflowStatusAssigneesInput!
  ): RemoveWorkflowStatusAssignees

  "**BETA** Remove assignees from an existing `WorkflowTask`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  removeWorkflowTaskAssignees(
    "**BETA** `RemoveWorkflowTaskAssignees` input argument."
    input: RemoveWorkflowTaskAssigneesInput!
  ): RemoveWorkflowTaskAssignees

  "**BETA** Export `CreativeTemplate` with provided parameters. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  exportCreative(
    "**BETA** `ExportCreative` input argument."
    input: ExportCreativeInput!
  ): ExportCreative

  "Reopens a resolved `AssetComment`. Requires `basic:write` scope to be accessible and `Comment` permission level `EDIT`."
  reopenAssetComment(
    "`ReopenAssetComment` input argument."
    input: ReopenAssetCommentInput!
  ): ReopenAssetComment

  "Replace an existing `Asset`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  replaceAsset(
    "`ReplaceAsset` input argument."
    input: ReplaceAssetInput!
  ): ReplaceAsset

  "**BETA** Replace an existing `AssetVariant`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  replaceAssetVariant(
    "**BETA** `ReplaceAssetVariant` input argument."
    input: ReplaceAssetVariantInput!
  ): ReplaceAssetVariant

  "**BETA** Replace a `File` in `ExternalDataSource`. Requires `basic:write` scope to be accessible` permission level `EDIT`."
  replaceExternalDataSourceFile(
    "**BETA** `ReplaceExternalDataSourceFile` input argument."
    input: ReplaceExternalDataSourceFileInput!
  ): ReplaceExternalDataSourceFile

  "Add a new reply to an existing `Asset` `Comment`. Requires `basic:write` scope to be accessible and `Asset` permission level `COMMENT`."
  replyToComment(
    "`ReplyToComment` input argument."
    input: ReplyToCommentInput!
  ): ReplyToComment

  "Resolve an open `AssetComment`. Requires `basic:write` scope to be accessible and `Comment` permission level `EDIT`."
  resolveAssetComment(
    "`ResolveAssetComment` input argument."
    input: ResolveAssetCommentInput!
  ): ResolveAssetComment

  "**BETA** Set `CustomMetadataProperty` values to any supported parent (`WorkspaceProject` | `Asset`). Attention: Existing `CustomMetadataProperty` values for the selected parents will be overwritten and\/or removed. Requires `basic:write` scope to be accessible and permission level `EDIT` for the respective parent."
  setCustomMetadata(
    "**BETA** `SetCustomMetadata` input argument."
    input: SetCustomMetadataInput!
  ): SetCustomMetadata

  "Replace the existing set of the `Assets` in the `Collection` with the new set of the `Assets`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  setCollectionAssets(
    "`SetCollectionAssets` input argument."
    input: SetCollectionAssetsInput!
  ): SetCollectionAssets

  "Sync `Asset` tags. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  syncAssetTags(
    "`SyncAssetTags` input argument."
    input: SyncAssetTagsInput!
  ): SyncAssetTags

  "Uninstall `Webhook`. Requires `basic:write` and `webhook:write` scopes to be accessible and `Project` permission level `EDIT`."
  uninstallWebhook(
    "`UninstallWebhook` input argument."
    input: UninstallWebhookInput!
  ): UninstallWebhook

  "Update an existing `Asset`. Requires `basic:write` scope to be accessible and `Asset` permission level `EDIT`."
  updateAsset(
    "`UpdateAsset` input argument."
    input: UpdateAssetInput!
  ): UpdateAsset

  "Update an existing `Collection`. Requires `basic:write` scope to be accessible and `Collection` permission level `EDIT`."
  updateCollection(
    "`UpdateCollection` input argument."
    input: UpdateCollectionInput!
  ): UpdateCollection

  "Update an existing `CustomMetadataProperty`. RequiresRequires `basic:write` scope to be accessible and `CustomMetadataProperty` permission level `EDIT`."
  updateCustomMetadataProperty(
    "`UpdateCustomMetadataProperty` input argument."
    input: UpdateCustomMetadataPropertyInput!
  ): UpdateCustomMetadataProperty

  "Update an existing `Folder`. Requires `basic:write` scope to be accessible and `Folder` permission level `EDIT`."
  updateFolder(
    "`UpdateFolder` input argument."
    input: UpdateFolderInput!
  ): UpdateFolder

  "**BETA** Update an existing `WorkflowChecklistItem`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  updateWorkflowChecklistItem(
    "**BETA** `UpdateWorkflowChecklistItem` input argument."
    input: UpdateWorkflowChecklistItemInput!
  ): UpdateWorkflowChecklistItem

  "**BETA** Update an existing `WorkflowChecklistPreset`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  updateWorkflowChecklistPreset(
    "**BETA** `UpdateWorkflowChecklistPreset` input argument."
    input: UpdateWorkflowChecklistPresetInput!
  ): UpdateWorkflowChecklistPreset

  "**BETA** Update an existing `WorkflowStatus`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  updateWorkflowStatus(
    "**BETA** `UpdateWorkflowStatus` input argument."
    input: UpdateWorkflowStatusInput!
  ): UpdateWorkflowStatus

  "**BETA** Update an existing `WorkflowTask`. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  updateWorkflowTask(
    "**BETA** `UpdateWorkflowTask` input argument."
    input: UpdateWorkflowTaskInput!
  ): UpdateWorkflowTask

  "Upload a new file. This stores the binary file temporarily so it can be then permanently linked to a specific type (ie. `Asset`, `Attachment`, `Revision`) after the upload is complete by using a different mutation. Requires `basic:write` scope to be accessible."
  uploadFile(
    "`UploadFile` input argument."
    input: UploadFileInput!
  ): UploadFile

  "**BETA** Create a new `Brand`. Requires `basic:write` scope to be accessible and `Account` permission level `EDIT`."
  createBrand(
    "`CreateBrand` input argument."
    input: CreateBrandInput!
  ): CreateBrand

  "**BETA** Delete an existing `Brand`. Requires `basic:write` scope to be accessible and `Brand` permission level `EDIT`."
  deleteBrand(
    "`DeleteBrand` input argument."
    input: DeleteBrandInput!
  ): DeleteBrand

  "**BETA** Update an existing `Brand`. Requires `basic:write` scope to be accessible and `Brand` permission level `EDIT`."
  updateBrand(
    "`UpdateBrand` input argument."
    input: UpdateBrandInput!
  ): UpdateBrand

  "**BETA** Cancels `CreativeJobs` by provided parameters. `CreativeJob` can be canceled prior to the `RENDERING` status. Requires `basic:write` scope to be accessible and `Project` permission level `EDIT`."
  cancelExportCreatives(
    "**BETA** `CancelExportCreatives` input argument."
    input: CancelExportCreativesInput!
  ): CancelExportCreatives
}

input AddAssetLicenseInput {
  "`Asset` Id."
  assetId: ID!

  "`License` Id."
  licenseId: ID!
}

type AddAssetLicense {
  "`Asset` details."
  asset: Asset

  "`License` details."
  license: License
}

input AddAssetMetadataFieldValueInput {
  "`Asset` Id."
  assetId: ID!

  "Metadata field Id."
  metadataFieldId: ID!

  "Value to be assigned to `Asset` and `Metadata Field`."
  value: String!
}

type AddAssetMetadataFieldValue {
  "`MetadataValue` Id."
  id: ID!

  "`User` who created the `MetadataValue`."
  creator: User!

  "`DateTime` of the `MetadataValue` creation."
  createdAt: DateTime!

  "`User` who last modified the `MetadataValue`."
  modifier: User

  "`DateTime` of the `MetadataValue` last modification."
  modifiedAt: DateTime

  "`MetadataField` related to the `MetadataValue`."
  metadataField: MetadataField!

  "`MetadataValue` value."
  value: String!
}

input AddAssetPreviewImageInput {
  "`Asset` Id."
  assetId: ID!

  "`File` Id. Signed Id returned by `uploadFile` mutation."
  fileId: ID!
}

type AddAssetPreviewImage {
  "The newly created `Asset` preview image processing job response."
  job: AssetPreviewProcessingJob!
}

type AssetPreviewProcessingJob {
  "`Asset` Id."
  assetId: ID!
}

input AddAssetRelationsInput {
  "`Asset` Id."
  assetId: ID!

  "Related `Asset` Id list."
  relatedAssetIds: [ID]!
}

type AddAssetRelations {
  "`Asset` details."
  asset: Asset!

  "Related `Assets` details."
  relatedAssets: [Asset]
}

input AddAssetTagsInput {
  "`Asset` Id."
  id: ID!

  "List of `Tag` values linked to `Asset`."
  tags: [TagInput]
}

input TagInput {
  "Tag name."
  value: String!
}

type AddAssetTags {
  "`Asset` details."
  asset: Asset
}

input AddCollectionAssetsInput {
  "`Collection` Id."
  collectionId: ID!

  "Ids of the `Assets` to add to the `Collection`. Must be in the same `Library` as the `Collection`."
  assetIds: [ID!]!
}

type AddCollectionAssets {
  "`Collection` details."
  collection: Collection
}

input AddCustomMetadataInput {
  "Set of parent Ids to which `CustomMetadata` should be added."
  parentIds: [ID!]!

  "`CustomMetadata` property and respective values to add to the given set of parents."
  customMetadata: [CustomMetadataInput!]!
}

input CustomMetadataInput {
  "`CustomMetadataProperty` Id."
  propertyId: ID!

  "`CustomMetadataProperty` value."
  value: Any
}

type AddCustomMetadata {
  "List of the parent Ids where the new `CustomMetadata` values were added."
  parentIds: [ID!]!
}

input AddCustomMetadataPropertyOptionsInput {
  "`CustomMetadataProperty` Id."
  propertyId: ID!

  "List of `CustomMetadataPropertyOption` items to add to existing `CustomMetadataProperty`."
  options: [AddCustomMetadataPropertyOptionInput!]!
}

input AddCustomMetadataPropertyOptionInput {
  "`CustomMetadataPropertyOption` value."
  value: String!

  "Define `CustomMetadataPropertyOption` as default. Applies to newly created `Assets` only."
  isDefault: Boolean = false
}

type AddCustomMetadataPropertyOptions {
  "`CustomMetadataProperty` details."
  customMetadataProperty: CustomMetadataProperty!
}

input AddWorkflowChecklistItemInput {
  "**BETA** `WorkflowTask` Id where the `WorkflowChecklistItem` should be created."
  id: ID!

  "**BETA** Content of the `WorkflowChecklistItem`."
  content: String!

  "**BETA** `User` Id of `WorkflowChecklistItem` assignee."
  assigneeUserId: ID
}

type AddWorkflowChecklistItem {
  "**BETA** The created `WorkflowChecklistItem`."
  checklistItem: WorkflowChecklistItem
}

input AddWorkflowChecklistPresetInput {
  "**BETA** `WorkflowStatus` Id where the `WorkflowChecklistPreset` should be created."
  id: ID!

  "**BETA** Content of the `WorkflowChecklistPreset`."
  content: String!

  "**BETA** `User` Id of `WorkflowChecklistPreset` assignee."
  assigneeUserId: ID
}

type AddWorkflowChecklistPreset {
  "**BETA** The created `WorkflowChecklistPreset`."
  checklistPreset: WorkflowChecklistPreset
}

input AddWorkflowStatusAssigneesInput {
  "**BETA** `WorkflowStatus` Id."
  id: ID!

  "**BETA** List of `User` Ids to be assigned to `WorkflowStatus`."
  userIds: [ID!]!
}

type AddWorkflowStatusAssignees {
  "**BETA** The updated `WorkflowStatus`."
  workflowStatus: WorkflowStatus
}

input AddWorkflowTaskAssigneesInput {
  "**BETA** `WorkflowTask` Id."
  id: ID!

  "**BETA** List of `User` Ids to assign to the `WorkflowTask`."
  userIds: [ID!]!
}

type AddWorkflowTaskAssignees {
  "**BETA** The updated `WorkflowTask`."
  workflowTask: WorkflowTask
}

input CreateAccountUserInput {
  "Name of the `AccountUser` to be created. Must be a valid non-empty string."
  name: String!

  "Email of the `AccountUser` to be created."
  email: Email!
}

type CreateAccountUser {
  "The newly created `AccountUser`."
  accountUser: AccountUser
}

input CreateAssetInput {
  "**DEPRECATED** `Library` or `Workspace` Id. This value is ignored if `parentId` is set. This field will be removed. Use `parentId` instead. | Date: 2023-07-01T00:00:00.000+00:00"
  projectId: ID

  "File Id. Signed Id returned in `uploadFile`."
  fileId: ID!

  "`Asset` title or display name."
  title: String!

  "**BETA** Alternative text for the `Asset`. Used by screen readers when the asset is not decorative."
  alternativeText: String

  "**BETA** Indicates whether the `Asset` is decorative and not meant to be read by screen readers. If true, alternative text is ignored."
  isDecorative: Boolean

  "`Asset` description."
  description: String = ""

  "`Asset` external Id."
  externalId: ID

  "Add `Asset` copyright details."
  copyright: CreateCopyrightInput

  "List of tags to create with `Asset`"
  tags: [TagInput]

  "Skip file's EXIF metadata. When true, it will ignore all file metadata contents."
  skipFileMetadata: Boolean = false

  "An array of strings representing the directory, if a folder does not exist, it is created. Example: [\"My Folder\", \"Sub-Folder\"] will create the necessary folders if they do not yet exist and place the `Asset` in it. **Important:** Cannot be used in conjunction with `parentId` that is from a `Folder`."
  directory: [String]

  "The parent Id, where the `Asset` should be located in. Should either be a `Library`, `WorkspaceProject` or `Folder` Id. **Important:** Cannot be used in conjunction with `directory` if the Id is from a `Folder`."
  parentId: ID

  "**DEPRECATED** `Asset` workflow status. Workflow logic will be automatically managed if not properly set. This field will be removed. | Date: 2022-07-01T00:00:00.000+00:00"
  workflowStatus: String

  "`Asset` will become available only during the interval.When undefined or `null` the `Asset` will be immediately and indefinitely available."
  availability: DateTimeRangeInput

  "`Asset` will expire once the defined date is reached."
  expiresAt: DateTime

  "Represents the Author of the `Asset`. Example: Photographer Name"
  author: String = ""

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColorInput
}

input CreateCopyrightInput {
  "`Asset` copyright status."
  status: CopyrightStatus! = UNKNOWN

  "`Asset` copyright notice. Supports medium text length."
  notice: String = ""
}

input DateTimeRangeInput {
  "Start `DateTime` of the range."
  from: DateTime

  "End `DateTime` of the range."
  to: DateTime
}

input RgbaColorInput {
  "Red color channel value."
  red: RgbColorChannel!

  "Green color channel value."
  green: RgbColorChannel!

  "Blue color channel value."
  blue: RgbColorChannel!

  "Alpha channel value."
  alpha: Percent!
}

type CreateAsset {
  "The newly created `Asset` processing job response."
  job: AssetProcessingJob!
}

type AssetProcessingJob {
  "`Asset` Id."
  assetId: ID!
}

input CreateAssetCommentInput {
  "Id of the `Asset` where you wish to create a new `AssetComment`."
  assetId: ID!

  "`AssetComment` content. Can include `User` mentions by wrapping an authorized `Project` `User` Id in the form of `@[user:<id>]` where `<id>` is the `User` integer or global identifier."
  content: String!

  "Add a `Marking` (highlighted area) to the new `AssetComment`."
  marking: MarkingInput
}

input MarkingInput {
  "The `Marking` position in percentage, in relation to the top left corner of the `Asset`."
  position: MarkingPositionInput

  "The `Marking` dimensions in percentage of the annotated subject dimensions."
  dimensions: MarkingDimensionsInput

  "The timeframe of the `Marking` area in percentage of total video length. Applicable to `Video` type `Assets` only."
  timeframe: MarkingTimeframeInput

  "The `Marking` page. Applicable to `Assets` with the type `Document` only."
  page: Int
}

input MarkingPositionInput {
  "The horizontal position of the `Marking` in percentage, in relation to the `Asset` top left corner."
  x: Percent!

  "The vertical position of the `Marking` in percentage, in relation to the `Asset` top left corner."
  y: Percent!
}

input MarkingDimensionsInput {
  "The width of the `Marking` area in percentage of the annotated subject total width."
  width: Percent!

  "The height of the `Marking` area in percentage of the annotated subject total height."
  height: Percent!
}

input MarkingTimeframeInput {
  "The start of the `Marking` area in percentage of total video length. Defaults to video start (0) when the timeframe input property is set."
  start: Percent

  "The end of the `Marking` area in percentage of total video length. Defaults to video end (1) when the timeframe input property is set."
  end: Percent
}

type CreateAssetComment {
  "`AssetComment` details."
  comment: AssetComment!
}

input CreatePermissionTokenInput {
  "**BETA** List of `parentIds` used on the permission token."
  parentIds: [ID!]!
}

type CreatePermissionToken {
  "**BETA** Permission token with the requested scope for `Assets` or `Collections`."
  permissionToken: String!
}

input CreateAssetSubmissionsInput {
  "`AssetSubmissionRequest` token."
  token: String!

  "`AssetSubmissionRequest` Id."
  requestId: ID!

  "File Ids. Signed Ids returned in `uploadFile`."
  fileIds: [ID!]!

  "**BETA** Should immediately create the `Assets` without requiring further approval."
  autoApprove: Boolean = false

  "`AssetSubmission` submitter."
  submitter: AssetSubmissionSubmitterInput!

  "`AssetSubmission`'s `Assets` metadata."
  metadata: AssetSubmissionMetadataInput
}

input AssetSubmissionSubmitterInput {
  "`AssetSubmission` submitter name."
  name: String!

  "`AssetSubmission` submitter email."
  email: Email!
}

input AssetSubmissionMetadataInput {
  "`AssetSubmission`'s `Asset` description."
  description: String

  "`AssetSubmission`'s `Asset` copyright details."
  copyright: AssetSubmissionCopyrightInput

  "`AssetSubmission`'s `Asset` `CustomMetadataProperty` values."
  custom: [AssetSubmissionCustomMetadataInput!]

  "`AssetSubmission`'s `Asset` `WorkflowStatus` Id."
  workflowStatusId: ID
}

input AssetSubmissionCopyrightInput {
  "`AssetSubmission`'s `Asset` author."
  author: String

  "`AssetSubmission`'s `Asset` copyright status."
  status: CopyrightStatus! = UNKNOWN

  "`AssetSubmission`'s `Asset` copyright notice. Supports medium text length (16 MB)."
  notice: String = ""
}

input AssetSubmissionCustomMetadataInput {
  "`CustomMetadataProperty` Id."
  propertyId: ID!

  "`CustomMetadataProperty` value."
  value: Any!
}

type CreateAssetSubmissions {
  "The newly created `AssetSubmission` Ids."
  assetSubmissionIds: [ID]!
}

input CreateAssetVariantInput {
  "File Id. Signed Id returned in `uploadFile`."
  fileId: ID!

  "`Asset` Id. Currently, only `Assets` from Logo and Icon `Library` type are supported."
  assetId: ID!

  "`AssetVariant` key composed of the color space and the file extension. Examples: RGB:JPG, CMYK:SVG"
  key: String!
}

type CreateAssetVariant {
  "The newly created `AssetVariant` processing job response."
  job: AssetVariantProcessingJob!
}

type AssetVariantProcessingJob {
  "`AssetVariant` Id."
  variantId: ID!
}

input CreateAttachmentInput {
  "Parent Id."
  parentId: ID!

  "File Id. Signed Id returned in `uploadFile`."
  fileId: ID!

  "Attachment name or display name."
  name: String!

  "Attachment external Id."
  externalId: ID
}

type CreateAttachment {
  "The newly created `Attachment` processing job response."
  job: AttachmentProcessingJob!
}

type AttachmentProcessingJob {
  "`Attachment` Id."
  attachmentId: ID!
}

input CreateCollectionInput {
  "Id of the parent where you wish to create a new `Collection`. Currently supported for `Library` type parent entities only."
  parentId: ID!

  "Name of the `Collection`."
  name: String!
}

type CreateCollection {
  "The newly created `Collection` details."
  collection: Collection!
}

input CreateCustomMetadataPropertyInput {
  "`CustomMetadataProperty` parent Id."
  parentId: ID!

  "`CustomMetadataProperty` display name."
  name: String!

  "`CustomMetadataProperty` type."
  type: CreateCustomMetadataPropertyTypeInput!

  "`CustomMetadataProperty` help text."
  helpText: String = ""

  "Define if `CustomMetadataProperty` is required."
  isRequired: Boolean = false

  "Set a `CustomMetadataProperty` default value. This setting will be ignored for properties that are not of `SELECT` or `MULTISELECT` type  (use options for these cases instead). Applies to newly uploaded `Assets` only."
  defaultValue: String

  "Position in the list of newly created `CustomMetadataProperty`."
  position: CustomMetadataPropertyPositionInput
}

input CreateCustomMetadataPropertyTypeInput {
  "`CustomMetadataProperty` type name."
  name: CustomMetadataPropertyTypeName!

  "Define CustomMetadataProperty` options for `SELECT` or `MULTISELECT` type properties."
  options: [CreateCustomMetadataPropertyTypeOptionInput!]
}

"List of possible `CustomMetadataProperty` type names."
enum CustomMetadataPropertyTypeName {
  SELECT
  MULTISELECT
  TEXT
  LONGTEXT
  DATE
  NUMBER
  URL
}

input CreateCustomMetadataPropertyTypeOptionInput {
  "`CustomMetadataPropertyOption` value."
  value: String!

  "Define `CustomMetadataPropertyOption` as default. Applies to newly created `Assets` only."
  isDefault: Boolean = false
}

input CustomMetadataPropertyPositionInput {
  "`CustomMetadataProperty` Id used as positional reference for `BEFORE` and `AFTER` placements."
  targetId: ID

  "`CustomMetadataProperty` position placement."
  placement: CustomMetadataPropertyPositionPlacement!
}

"List of possible `CustomMetadataProperty` position placement options."
enum CustomMetadataPropertyPositionPlacement {
  FIRST
  LAST
  BEFORE
  AFTER
}

type CreateCustomMetadataProperty {
  "The newly created `CustomMetadataProperty`."
  property: CustomMetadataProperty!
}

input CreateExternalAssetInput {
  "Destination `Project` Id."
  projectId: ID!

  "External `Asset` `Url`."
  url: Url!

  "External `Asset` title or display name."
  title: String!

  "External `Asset` description."
  description: String = ""

  "External `Asset` fixed width."
  width: Int

  "External `Asset` fixed height."
  height: Int

  "External `Asset` allow interactions."
  allowInteractions: Boolean = true

  "External `Asset` external Id."
  externalId: ID

  "External `Asset` copyright details."
  copyright: CreateCopyrightInput

  "External `Asset` destination folder. Folders will be created if they don't exist."
  directory: [String] = []

  "Expiry Date. External `Asset` will expire once the defined date is reached."
  expiresAt: DateTime

  "Represents the Author of the External `Asset`."
  author: String = ""
}

type CreateExternalAsset {
  "The newly created `Asset` processing job response."
  job: AssetProcessingJob!
}

input CreateFolderInput {
  "The parent Id of the `Folder` creation destination. Possible identifiers are `Library`\/`Workspace` or `Folder`."
  parentId: ID!

  "`Folder` name."
  name: String!

  "`Folder` description."
  description: String
}

type CreateFolder {
  "The newly created `Folder`."
  folder: Folder
}

input CreateLicenseInput {
  "`Library` Id."
  projectId: ID!

  "`License` title."
  title: String!

  "`License` terms."
  license: String!

  "Apply `License` to new assets by default."
  addByDefault: Boolean = false

  "Require user to accept `License` terms before download."
  requireConsensus: Boolean = false
}

type CreateLicense {
  "`License` details."
  license: License!
}

input CreateMetadataFieldInput {
  "`Project`\/`Library` Id where metadata field should be created."
  projectId: ID!

  "Create custom metadata field label."
  label: String!

  "Create custom metadata field type."
  type: MetadataFieldType! = TEXT

  "Create custom metadata field allowed values. Only valid for `SELECT` type fields."
  values: [MetadataFieldValuesInput]

  "New custom metadata default value option. This value will be set to all new assets."
  defaultValue: String

  "Allow multiple values in `SELECT` type `Metadata Field`."
  allowMultipleValues: Boolean = false

  "Allow an empty value as a valid `SELECT` type `Metadata Field` value."
  allowEmptyValue: Boolean = false

  "Allow users to search for `Metadata Field` values in the Frontify UI."
  isSearchable: Boolean = true

  "Allow users to edit `Metadata Field` values in the Frontify UI."
  isEditable: Boolean = true

  "Show\/hide `Metadata Field` values in the Frontify UI."
  isVisible: Boolean = true
}

"List of possible custom `MetadataField` types."
enum MetadataFieldType {
  SELECT
  TEXT
  LONGTEXT
  DATE
  NUMBER
}

input MetadataFieldValuesInput {
  "Possible value of `SELECT` type `Metadata Field`."
  value: String!

  "Optional setting to define current `SELECT` type `Metadata Field` value as default."
  default: Boolean = false
}

type CreateMetadataField {
  "Created `MetadataField`."
  metadataField: MetadataField!
}

input CreateShareLinkInput {
  "**BETA** The `parentId` of the `ShareLink`. Supported types of `parentId` are `project` and `libraryDocument` Id."
  parentId: ID!

  "**BETA** Permission token composed of timestamp, payload and scope."
  permissionToken: String!

  "**BETA** The usage key of the resource to which the `ShareLink` is attached. Example: `asset:15`."
  usageKey: String!

  "**BETA** `ShareLink` expiration date."
  expiresAt: DateTime

  "**BETA** `ShareLink` password."
  password: String
}

type CreateShareLink {
  "**BETA** The created `ShareLink`."
  shareLink: ShareLink!
}

type ShareLink {
  "**BETA** `ShareLink` `Url`."
  url: Url!
}

input CreateWorkflowStatusInput {
  "**BETA** `Workflow` Id where `WorkflowStatus` should be created."
  workflowId: ID!

  "**BETA** Title of the `WorkflowStatus`."
  title: String!

  "**BETA** Color of the `WorkflowStatus`."
  color: RgbaColorInput
}

type CreateWorkflowStatus {
  "**BETA** The newly created `WorkflowStatus`."
  workflowStatus: WorkflowStatus
}

input CreateAssetWorkflowTaskInput {
  "**BETA** Id of the `Asset` which should be linked to the `WorkflowTask`."
  assetId: ID!

  "**BETA** Id of the `WorkflowStatus` where the `WorkflowTask` should be created."
  workflowStatusId: ID!

  "**BETA** List of `User` ids to be assigned to the `WorkflowTask`. Currently, only one Id is supported."
  assigneeUserIds: [ID!]

  "**BETA** `WorkflowTask` enter message. Optionally required by a `EnterRule` of the given `WorkflowStatus`."
  statusEnterMessage: String
}

type CreateAssetWorkflowTask {
  "**BETA** The newly created `WorkflowTask`."
  workflowTask: WorkflowTask
}

input CreateWorkspaceProjectInput {
  "Id of the `Brand` where `Project` should be inserted."
  brandId: ID!

  "`Workspace` type `Project` name."
  name: String!
}

type CreateWorkspaceProject {
  "`WorkspaceProject` details."
  project: Workspace!
}

input DeleteAccountUserInput {
  "Id of the `AccountUser` to delete."
  id: ID!

  "Id of the `AccountUser` to whom the permissions of the deleted `AccountUser` are being delegated."
  delegateId: ID!

  "Id of the `Account` from which the `AccountUser` should be deleted."
  accountId: ID!
}

type DeleteAccountUser {
  "Id of the deleted `AccountUser`."
  id: ID
}

input DeleteAssetInput {
  "Id of the `Asset` to delete."
  id: ID!
}

type DeleteAsset {
  "The Id of the deleted `Asset`."
  id: ID!

  "**DEPRECATED** `Asset` details. This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00"
  asset: Asset! @deprecated(reason: "This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00")
}

input DeleteAttachmentInput {
  "Id of the `Attachment` to delete."
  id: ID!
}

type DeleteAttachment {
  "The Id of the deleted `Attachment`."
  id: ID!

  "**DEPRECATED** `Attachment` details. This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00"
  attachment: Attachment! @deprecated(reason: "This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00")
}

input DeleteAssetVariantInput {
  "`Asset` Id of the `AssetVariant` to delete."
  assetId: String!

  "Key of the `AssetVariant` to delete. Composed of the color space and the file extension. Examples: RGB:JPG, CMYK:SVG."
  key: String!
}

type DeleteAssetVariant {
  "`AssetVariant` Id."
  id: ID!
}

input DeleteCollectionInput {
  "`Collection` Id."
  collectionId: ID!
}

type DeleteCollection {
  "The Id of the deleted `Collection`."
  id: ID!

  "**DEPRECATED** `Collection` details. This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00"
  collection: Collection! @deprecated(reason: "This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00")
}

input DeleteCommentInput {
  "Id of the `AssetComment` to delete."
  id: ID!
}

type DeleteComment {
  "The Id of the deleted `Comment`."
  id: ID!

  "**DEPRECATED** `Comment` details. This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00"
  comment: Comment! @deprecated(reason: "This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00")
}

input DeleteCustomMetadataPropertyInput {
  "`CustomMetadataProperty` Id."
  id: ID!
}

type DeleteCustomMetadataProperty {
  "The Id of the deleted `CustomMetadataProperty`."
  id: ID!
}

input DeleteFoldersInput {
  "Ids of the `Folders` to delete."
  ids: [ID!]!
}

type DeleteFolders {
  "List of the deleted `Folder` ids."
  ids: [ID!]
}

input DeleteLicenseInput {
  "Id of the `License` to delete."
  id: ID!
}

type DeleteLicense {
  "The Id of the deleted `License`."
  id: ID!

  "**DEPRECATED** `License` details. This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00"
  license: License! @deprecated(reason: "This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00")
}

input DeleteMetadataFieldInput {
  "Id of the `MetadataField` to delete."
  id: ID!
}

type DeleteMetadataField {
  "The Id of the deleted `MetadataField`."
  id: ID!

  "**DEPRECATED** Deleted `MetadataField`. This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00"
  metadataField: MetadataField! @deprecated(reason: "This field will be removed. Use `id` instead. | Date: 2024-01-01T00:00:00.000+00:00")
}

input DeleteWorkflowStatusInput {
  "**BETA** Id of the `WorkflowStatus` to be deleted."
  id: ID!
}

type DeleteWorkflowStatus {
  "The Id of the deleted `WorkflowStatus`."
  id: ID!
}

input DeleteWorkflowTaskInput {
  "**BETA** Id of the `WorkflowTask` to be deleted."
  id: ID!
}

type DeleteWorkflowTask {
  "The Id of the deleted `WorkflowTask`."
  id: ID!
}

input EditCommentInput {
  "`AssetComment` Id you wish to edit."
  id: ID!

  "`AssetComment` content to edit. Can include `User` mentions by wrapping an authorized `Project` `User` Id in the form of `@[user:<id>]` where `<id>` is the user identifier."
  content: String!
}

type EditComment {
  "`Comment` details."
  comment: Comment!
}

input InstallProjectWebhookInput {
  "Destination `Project` Id."
  projectId: ID!

  "`Url` to send the `ProjectWebhook` notification to."
  notificationUrl: Url!

  "`ProjectWebhook` name."
  name: String!
}

type InstallProjectWebhook {
  "`Webhook` details."
  webhook: Webhook!
}

input InviteProjectUserInput {
  "Id of the `Project` you want to invite `User` to."
  projectId: ID!

  "Email address of the `User` you would like to invite."
  email: Email!

  "`Project` permission level of the `User` you are inviting."
  permission: ProjectPermission! = VIEW

  "Start `Date` for `User` access permission validity."
  validFrom: DateTime

  "End `Date` for `User` access permission validity."
  validTo: DateTime
}

"List of possible `Project` permission levels."
enum ProjectPermission {
  EDIT
  COMMENT
  VIEW
  ADMIN
  TRANSLATE
}

type InviteProjectUser {
  "`Project` where `User` was invited to."
  project: Project
}

input MoveAssetsInput {
  "Ids of the `Asset` items to be moved."
  assetIds: [ID!]!

  "Id of the destination entity where `Asset` items should be moved to. Allows `Library`\/`Workspace`\/`Folder` Ids only."
  destinationId: ID!
}

type MoveAssets {
  "List of moved `Asset` items."
  assets: [Asset!]
}

input MoveFoldersInput {
  "Ids of the `Folder` items to be moved."
  folderIds: [ID!]!

  "Id of the destination entity where `Folder` items should be moved to. Allows `Library`\/`Workspace`\/`Folder` Ids only."
  destinationId: ID!
}

type MoveFolders {
  "List of moved `Folder` ids."
  ids: [ID!]
}

input MoveWorkflowTaskInput {
  "**BETA** The Id of the destination `WorkflowStatus`."
  workflowStatusId: ID!

  "**BETA** List of `WorkflowTask` Ids to move. Limited to 100 Ids."
  workflowTaskIds: [ID!]!

  "**BETA** `WorkflowTask` enter message. Optionally required by a `EnterRule` of the given `WorkflowStatus`."
  statusEnterMessage: String
}

type MoveWorkflowTask {
  "**BETA** The `WorkflowStatus` with the moved tasks."
  workflowStatus: WorkflowStatus
}

input RemoveAssetLicenseInput {
  "`Asset` Id."
  assetId: ID!

  "`License` Id."
  licenseId: ID!
}

type RemoveAssetLicense {
  "`Asset` details."
  asset: Asset

  "`License` details."
  license: License
}

input RemoveAssetPreviewImageInput {
  "`Asset` Id."
  id: ID!
}

type RemoveAssetPreviewImage {
  "`Asset` details."
  asset: Asset
}

input RemoveAssetRelationsInput {
  "`Asset` Id."
  assetId: ID!

  "Related `Asset` Id list."
  relatedAssetIds: [ID!]!
}

type RemoveAssetRelations {
  "`Asset` details."
  asset: Asset!

  "Related `Asset` items details."
  relatedAssets: [Asset!]!
}

input RemoveAssetTagsInput {
  "`Asset` Id."
  id: ID!

  "`Asset` tags."
  tags: [TagInput]
}

type RemoveAssetTags {
  "`Asset` details."
  asset: Asset
}

input RemoveCollectionAssetsInput {
  "`Collection` Id."
  collectionId: ID!

  "Ids of the `Assets` to remove from the `Collection`."
  assetIds: [ID!]!
}

type RemoveCollectionAssets {
  "`Collection` details."
  collection: Collection
}

input RemoveCustomMetadataInput {
  "List of parent Ids where `CustomMetadata` should be removed from."
  parentIds: [ID!]!

  "`CustomMetadata` to be removed from the list of parent Ids."
  customMetadata: [CustomMetadataInput!]!
}

type RemoveCustomMetadata {
  "List of parentIds with removed `CustomMetadata` values."
  parentIds: [ID!]!
}

input RemoveCustomMetadataPropertyOptionsInput {
  "`CustomMetadataProperty` Id."
  propertyId: ID!

  "`CustomMetadataPropertyOption` Ids."
  optionIds: [ID!]!
}

type RemoveCustomMetadataPropertyOptions {
  "`CustomMetadataProperty` details."
  customMetadataProperty: CustomMetadataProperty!
}

input RemoveMetadataValueInput {
  "`MetadataValue` Id."
  id: ID!
}

type RemoveMetadataValue {
  "`MetadataValue` Id."
  id: ID!

  "`User` who created the `MetadataValue`."
  creator: User!

  "`DateTime` of the `MetadataValue` creation."
  createdAt: DateTime!

  "`User` who last modified the `MetadataValue`."
  modifier: User

  "`DateTime` of the `MetadataValue` last modification."
  modifiedAt: DateTime

  "`MetadataField` related to the `MetadataValue`."
  metadataField: MetadataField!

  "`MetadataValue` value."
  value: String!
}

input RemoveWorkflowChecklistItemInput {
  "**BETA** The Id of the `WorkflowChecklistItem` to remove."
  id: ID!
}

type RemoveWorkflowChecklistItem {
  "**BETA** The deleted `WorkflowChecklistItem`."
  checklistItem: WorkflowChecklistItem
}

input RemoveWorkflowChecklistPresetInput {
  "**BETA** The Id of the `WorkflowChecklistPreset` to remove."
  id: ID!
}

type RemoveWorkflowChecklistPreset {
  "**BETA** The deleted `WorkflowChecklistPreset`."
  checklistPreset: WorkflowChecklistPreset
}

input RemoveWorkflowStatusAssigneesInput {
  "**BETA** `WorkflowStatus` Id."
  id: ID!

  "**BETA** List of `User` Ids to be unassigned from `WorkflowStatus`."
  userIds: [ID!]!
}

type RemoveWorkflowStatusAssignees {
  "**BETA** The updated `WorkflowStatus`."
  workflowStatus: WorkflowStatus
}

input RemoveWorkflowTaskAssigneesInput {
  "**BETA** `WorkflowTask` Id."
  id: ID!

  "**BETA** List of `User` Ids to unassign from the `WorkflowTask`."
  userIds: [ID!]!
}

type RemoveWorkflowTaskAssignees {
  "**BETA** The updated `WorkflowTask`."
  workflowTask: WorkflowTask
}

input ExportCreativeInput {
  "**BETA** `CreativeTemplateId` Id."
  templateId: ID!

  "**BETA** `ExportCreativeDestinationInput` where the exported file will be uploaded."
  destination: ExportCreativeDestinationInput

  "**BETA** List of `CreativeVariableInput` which will be applied to the template."
  variables: [CreativeVariableInput]

  "**BETA** `ExportCreativeOptionsInput` data."
  options: ExportCreativeOptionsInput
}

input ExportCreativeDestinationInput {
  "**BETA** `Project` Id destination for the exported Creative."
  destinationId: ID!

  "**BETA** `Title` of file."
  title: String!
}

input CreativeVariableInput {
  "**BETA** Template variable `Key`."
  key: String!

  "**BETA** `Value` of template variable."
  value: Any
}

input ExportCreativeOptionsInput {
  "**BETA** `Format` of exported file."
  format: CreativeExportFormat

  "**BETA** `Quality` of exported file. Supported only for `JPG` `Format`."
  quality: CreativeExportQuality

  "**BETA** `TransparentBackground` export parameter. Supported only by `PNG` `Format`."
  hasTransparentBackground: Boolean

  "**BETA** `Cropmarks` export parameter."
  hasCropmarks: Boolean! = false

  "**BETA** `Bleed` export parameter."
  bleed: ExportCreativeBleedInput

  "**BETA** List of pages to export. If provided, validates that all requested pages exist in a template before export. If not provided, all pages will be exported."
  pages: [Int!]
}

"List of possible `CreativeExportOptionsInput` formats."
enum CreativeExportFormat {
  PNG
  JPG
  PDF
}

"Compression level, affecting quality and filesize of the exported Creative."
enum CreativeExportQuality {
  MAXIMUM
  HIGH
  MEDIUM
  LOW
}

input ExportCreativeBleedInput {
  "**BETA** `Top` value in mm."
  top: Float!

  "**BETA** `Right` value in mm."
  right: Float!

  "**BETA** `Bottom` value in mm."
  bottom: Float!

  "**BETA** `Left` value in mm."
  left: Float!
}

type ExportCreative {
  "**BETA** The newly created `CreativeJob`."
  job: CreativeExport!
}

input ReopenAssetCommentInput {
  "`AssetComment` Id to reopen."
  id: ID!
}

type ReopenAssetComment {
  "The reopened `AssetComment`."
  comment: AssetComment
}

input ReplaceAssetInput {
  "Parent `Asset` Id."
  assetId: ID!

  "Signed file Id returned in `uploadFile`."
  fileId: ID!

  "Skip file's EXIF metadata. When true, it will ignore all file metadata contents."
  skipFileMetadata: Boolean = false
}

type ReplaceAsset {
  "The newly created `Asset` processing job response."
  job: AssetProcessingJob!
}

input ReplaceAssetVariantInput {
  "File Id. Signed Id returned in `uploadFile`."
  fileId: ID!

  "Parent `Asset` Id of the `AssetVariant` to replace. Currently, only `Assets` from Logo and Icon `Library` type are supported."
  assetId: ID!

  "`AssetVariant` key to replace. Composed of the color space and the file extension. Examples: RGB:JPG, CMYK:SVG"
  key: String!
}

type ReplaceAssetVariant {
  "The newly created `AssetVariant` processing job response."
  job: AssetVariantProcessingJob!
}

input ReplaceExternalDataSourceFileInput {
  "`ExternalDataSource` Id."
  externalDataSourceId: ID!

  "Signed `File` Id."
  fileId: ID!
}

type ReplaceExternalDataSourceFile {
  "`ExternalDataSource` Id."
  externalDataSourceId: ID!
}

input ReplyToCommentInput {
  "`AssetComment` Id of the comment you want to reply to."
  id: ID!

  "`AssetComment` reply content. Can include `User` mentions by wrapping an authorized `Project` `User` Id in the form of `@[user:<id>]` where `<id>` is the `User` integer or global identifier."
  reply: String!
}

type ReplyToComment {
  "`AssetCommentReply` details."
  reply: AssetCommentReply!
}

input ResolveAssetCommentInput {
  "`AssetComment` Id to resolve."
  id: ID!
}

type ResolveAssetComment {
  "The resolved `AssetComment`."
  comment: AssetComment
}

input SetCustomMetadataInput {
  "List of `parentIds` where `CustomMetadata` should be set."
  parentIds: [ID!]!

  "`CustomMetadata` to be set to the list of `parentIds`."
  customMetadata: [CustomMetadataInput!]!
}

type SetCustomMetadata {
  "List of parentIds with newly `CustomMetadata` values set."
  parentIds: [ID!]!
}

input SetCollectionAssetsInput {
  "`Collection` Id."
  collectionId: ID!

  "Ids of the `Assets` to replace existing `Assets` in the `Collection`. Must be in the same `Library` as the `Collection`."
  assetIds: [ID!]!
}

type SetCollectionAssets {
  "`Collection` details."
  collection: Collection
}

input SyncAssetTagsInput {
  "`Asset` Id."
  id: ID!

  "`Asset` tags."
  tags: [TagInput]
}

type SyncAssetTags {
  "`Asset` details."
  asset: Asset
}

input UninstallWebhookInput {
  "Id of the `Webhook` to be uninstalled."
  id: ID!
}

type UninstallWebhook {
  "`Webhook` details."
  webhook: Webhook!
}

input UpdateAssetInput {
  "`Asset` Id."
  id: ID!

  "`Asset` data."
  data: UpdateAssetDataInput!
}

input UpdateAssetDataInput {
  "`Asset` title or display name."
  title: String

  "**BETA** Alternative text for the `Asset`. Used by screen readers when the asset is not decorative."
  alternativeText: String

  "**BETA** Indicates whether the `Asset` is decorative and not meant to be read by screen readers. If true, alternative text is ignored."
  isDecorative: Boolean

  "`Asset` filename, including extension."
  filename: String

  "`Asset` description."
  description: String

  "Change `Asset` copyright details."
  copyright: UpdateCopyrightInput

  "Modify expiry date. `Asset` will expire once the defined date is reached."
  expiresAt: DateTime

  "Represents the Author of the `Asset`. Example: Photographer Name."
  author: String

  "**BETA** Background color of the `Asset` preview."
  previewBackgroundColor: RgbaColorInput
}

input UpdateCopyrightInput {
  "`Asset` copyright status."
  status: CopyrightStatus!

  "`Asset` copyright notice."
  notice: String
}

type UpdateAsset {
  "`Asset` details."
  asset: Asset
}

input UpdateCollectionInput {
  "`Collection` Id."
  collectionId: ID!

  "`Collection` data."
  data: UpdateCollectionDataInput!
}

input UpdateCollectionDataInput {
  "Name of the `Collection`."
  name: String!
}

type UpdateCollection {
  "`Collection` details."
  collection: Collection!
}

input UpdateCustomMetadataPropertyInput {
  "`CustomMetadataProperty` Id."
  id: ID!

  "`CustomMetadataProperty` data."
  data: UpdateCustomMetadataPropertyDataInput!
}

input UpdateCustomMetadataPropertyDataInput {
  "`CustomMetadataProperty` display name."
  name: String

  "`CustomMetadataProperty` type details."
  type: UpdateCustomMetadataPropertyTypeInput

  "`CustomMetadataProperty` help text."
  helpText: String

  "Define if `CustomMetadataProperty` is required."
  isRequired: Boolean

  "Set a `CustomMetadataProperty` default value. This setting will be ignored for properties that are not of `SELECT` or `MULTISELECT` type  (use options for these cases instead). Applies to newly uploaded `Assets` only."
  defaultValue: String
}

input UpdateCustomMetadataPropertyTypeInput {
  "Define CustomMetadataProperty` options for `SELECT` or `MULTISELECT` type properties."
  options: [UpdateCustomMetadataPropertyTypeOptionInput!]
}

input UpdateCustomMetadataPropertyTypeOptionInput {
  "`CustomMetadataPropertyOption` Id. This is an optional field only consider for editing purposes."
  id: ID

  "`CustomMetadataPropertyOption` value."
  value: String!

  "Define `CustomMetadataPropertyOption` as default. Applies to newly created `Assets` only."
  isDefault: Boolean = false
}

type UpdateCustomMetadataProperty {
  "Name of the updated `CustomMetadataProperty`."
  property: CustomMetadataProperty!
}

input UpdateFolderInput {
  "`Folder` Id."
  id: ID!

  "`Folder` data."
  data: UpdateFolderDataInput!
}

input UpdateFolderDataInput {
  "`Folder` name or display name."
  name: String

  "`Folder` description."
  description: String
}

type UpdateFolder {
  "`Folder` details."
  folder: Folder
}

input UpdateWorkflowChecklistItemInput {
  "**BETA** `WorkflowChecklistItem` Id."
  id: ID!

  "`WorkflowChecklistItem` data."
  data: UpdateWorkflowChecklistItemDataInput!
}

input UpdateWorkflowChecklistItemDataInput {
  "**BETA** Content of the `WorkflowChecklistItem`."
  content: String

  "**BETA** `User` Id of `WorkflowChecklistItem` assignee."
  assigneeUserId: ID
}

type UpdateWorkflowChecklistItem {
  "**BETA** The updated `WorkflowChecklistItem`."
  checklistItem: WorkflowChecklistItem
}

input UpdateWorkflowChecklistPresetInput {
  "**BETA** `WorkflowChecklistPreset` Id."
  id: ID!

  "`WorkflowChecklistPreset` data."
  data: UpdateWorkflowChecklistPresetDataInput!
}

input UpdateWorkflowChecklistPresetDataInput {
  "**BETA** Content of the `WorkflowChecklistPreset`."
  content: String

  "**BETA** `User` Id of `WorkflowChecklistPreset` assignee."
  assigneeUserId: ID
}

type UpdateWorkflowChecklistPreset {
  "**BETA** The updated `ChecklistPreset`."
  checklistPreset: WorkflowChecklistPreset
}

input UpdateWorkflowStatusInput {
  "**BETA** `WorkflowStatus` Id."
  id: ID!

  "**BETA** `WorkflowStatus` data."
  data: UpdateWorkflowStatusDataInput!
}

input UpdateWorkflowStatusDataInput {
  "**BETA** `WorkflowStatus` title."
  title: String

  "**BETA** `WorkflowStatus` color."
  color: RgbaColorInput
}

type UpdateWorkflowStatus {
  "**BETA** The updated `WorkflowStatus`."
  workflowStatus: WorkflowStatus
}

input UpdateWorkflowTaskInput {
  "**BETA** `WorkflowTask` Id."
  id: ID!

  "`WorkflowTask` data."
  data: UpdateWorkflowTaskDataInput!
}

input UpdateWorkflowTaskDataInput {
  "**BETA** `WorkflowTask` title."
  title: String

  "**BETA** `WorkflowTask` description."
  description: String
}

type UpdateWorkflowTask {
  "**BETA** The updated `WorkflowTask`."
  workflowTask: WorkflowTask
}

input UploadFileInput {
  "`File` name. This value will be passed on to the `fileId` input variable used in file mutations such as `createAsset`, `replaceAsset`, `createAttachment` or `addAssetPreviewImage`."
  filename: String!

  "`File` size in bytes. Value must be a positive integer up to 5TB."
  size: BigInt!

  "**DEPRECATED** `File` chunk size in bytes. Value must be integer between 5MB and 1GB. Please, consider using bigger chunk sizes for huge files to prevent issues. This field will be removed. | Date: 2025-07-01T00:00:00.000+00:00"
  chunkSize: BigInt = 104857600
}

type UploadFile {
  "Signed Id."
  id: ID!

  "Arrays with upload `Urls` to upload the file."
  urls: [Url]!
}

input CreateBrandInput {
  "`Brand` name."
  name: String!

  "`Brand` color. When not provided, a default color will be used."
  color: RgbaColorInput
}

type CreateBrand {
  "The newly created `Brand`."
  brand: Brand!
}

input DeleteBrandInput {
  "`Brand` id."
  id: ID!
}

type DeleteBrand {
  "The deleted `Brand` id."
  id: ID!
}

input UpdateBrandInput {
  "`Brand` id."
  id: ID!

  "`Brand` data."
  data: UpdateBrandDataInput!
}

input UpdateBrandDataInput {
  "`Brand` name."
  name: String

  "`Brand` color. When not provided, the color will not be updated."
  color: RgbaColorInput
}

type UpdateBrand {
  "The updated `Brand`."
  brand: Brand!
}

input CancelExportCreativesInput {
  "**BETA** List of `CreativeJob` Ids that should be canceled."
  ids: [ID]!
}

type CancelExportCreatives {
  "**BETA** A list of `CreativeJobs` that have been canceled successfully."
  canceledJobs: [CreativeExport]!
}
